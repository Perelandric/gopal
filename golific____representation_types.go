/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"encoding/json"
)

/*****************************

Payment struct

******************************/
func NewPayment() *Payment {
	return &Payment{
		private: private_17nx6fnrqzw5w{},
	}
}

// TODO: Add `billing_agreement_tokens`, `payment_instruction`
type Payment struct {
	private private_17nx6fnrqzw5w
	*connection
	ExperienceProfileId string `json:"experience_profile_id"`
	*payment_error
}

type private_17nx6fnrqzw5w struct {
	Intent        intentEnum        `json:"intent,omitempty"`
	Payer         payer             `json:"payer,omitempty"`
	Transactions  Transactions      `json:"transactions,omitempty"`
	RedirectUrls  Redirects         `json:"redirect_urls,omitempty"`
	State         stateEnum         `json:"state,omitempty"`
	Id            string            `json:"id,omitempty"`
	FailureReason FailureReasonEnum `json:"failure_reason,omitempty"`
	CreateTime    dateTime          `json:"create_time,omitempty"`
	UpdateTime    dateTime          `json:"update_time,omitempty"`
	Links         links             `json:"links,omitempty"`
}

type json_17nx6fnrqzw5w struct {
	*private_17nx6fnrqzw5w
	*connection
	ExperienceProfileId string `json:"experience_profile_id"`
	*payment_error
}

func (self *Payment) Intent() intentEnum {
	return self.private.Intent
}

func (self *Payment) Payer() payer {
	return self.private.Payer
}

func (self *Payment) Transactions() Transactions {
	return self.private.Transactions
}

func (self *Payment) RedirectUrls() Redirects {
	return self.private.RedirectUrls
}

func (self *Payment) State() stateEnum {
	return self.private.State
}

func (self *Payment) Id() string {
	return self.private.Id
}

func (self *Payment) FailureReason() FailureReasonEnum {
	return self.private.FailureReason
}

func (self *Payment) CreateTime() dateTime {
	return self.private.CreateTime
}

func (self *Payment) UpdateTime() dateTime {
	return self.private.UpdateTime
}

func (self *Payment) Links() links {
	return self.private.Links
}

func (self *Payment) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_17nx6fnrqzw5w{
		&self.private,
		self.connection,
		self.ExperienceProfileId,
		self.payment_error,
	})
}

func (self *Payment) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "experience_profile_id":
			err = json.Unmarshal(rawMsg, &self.ExperienceProfileId)
		case "intent":
			err = json.Unmarshal(rawMsg, &self.private.Intent)
		case "payer":
			err = json.Unmarshal(rawMsg, &self.private.Payer)
		case "transactions":
			err = json.Unmarshal(rawMsg, &self.private.Transactions)
		case "redirect_urls":
			err = json.Unmarshal(rawMsg, &self.private.RedirectUrls)
		case "state":
			err = json.Unmarshal(rawMsg, &self.private.State)
		case "id":
			err = json.Unmarshal(rawMsg, &self.private.Id)
		case "failure_reason":
			err = json.Unmarshal(rawMsg, &self.private.FailureReason)
		case "create_time":
			err = json.Unmarshal(rawMsg, &self.private.CreateTime)
		case "update_time":
			err = json.Unmarshal(rawMsg, &self.private.UpdateTime)
		case "links":
			err = json.Unmarshal(rawMsg, &self.private.Links)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

Transaction struct

******************************/
func NewTransaction() *Transaction {
	return &Transaction{
		private: private_155t931o9ljxs{},
	}
}

type Transaction struct {
	private        private_155t931o9ljxs
	Description    string         `json:"description,omitempty"`
	InvoiceNumber  string         `json:"invoice_number,omitempty"`
	Custom         string         `json:"custom,omitempty"`
	SoftDescriptor string         `json:"soft_descriptor,omitempty"`
	PaymentOptions paymentOptions `json:"payment_options,omitempty"`
}

type private_155t931o9ljxs struct {
	ItemList         *itemList        `json:"item_list,omitempty"`
	Amount           amount           `json:"amount"`
	RelatedResources relatedResources `json:"related_resources,omitempty"`
}

type json_155t931o9ljxs struct {
	*private_155t931o9ljxs
	Description    string         `json:"description,omitempty"`
	InvoiceNumber  string         `json:"invoice_number,omitempty"`
	Custom         string         `json:"custom,omitempty"`
	SoftDescriptor string         `json:"soft_descriptor,omitempty"`
	PaymentOptions paymentOptions `json:"payment_options,omitempty"`
}

func (self *Transaction) ItemList() *itemList {
	return self.private.ItemList
}

func (self *Transaction) Amount() amount {
	return self.private.Amount
}

func (self *Transaction) RelatedResources() relatedResources {
	return self.private.RelatedResources
}

func (self *Transaction) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_155t931o9ljxs{
		&self.private,
		self.Description,
		self.InvoiceNumber,
		self.Custom,
		self.SoftDescriptor,
		self.PaymentOptions,
	})
}

func (self *Transaction) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "item_list":
			err = json.Unmarshal(rawMsg, &self.private.ItemList)
		case "amount":
			err = json.Unmarshal(rawMsg, &self.private.Amount)
		case "related_resources":
			err = json.Unmarshal(rawMsg, &self.private.RelatedResources)
		case "description":
			err = json.Unmarshal(rawMsg, &self.Description)
		case "invoice_number":
			err = json.Unmarshal(rawMsg, &self.InvoiceNumber)
		case "custom":
			err = json.Unmarshal(rawMsg, &self.Custom)
		case "soft_descriptor":
			err = json.Unmarshal(rawMsg, &self.SoftDescriptor)
		case "payment_options":
			err = json.Unmarshal(rawMsg, &self.PaymentOptions)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

itemList struct

******************************/
func NewItemList() *itemList {
	return &itemList{
		private: private_1xli41tuenweq{},
	}
}

type itemList struct {
	private private_1xli41tuenweq
}

type private_1xli41tuenweq struct {
	Items           Items            `json:"items,omitempty"`
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

type json_1xli41tuenweq struct {
	*private_1xli41tuenweq
}

func (self *itemList) Items() Items {
	return self.private.Items
}

func (self *itemList) ShippingAddress() *ShippingAddress {
	return self.private.ShippingAddress
}

func (self *itemList) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1xli41tuenweq{
		&self.private,
	})
}

func (self *itemList) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "items":
			err = json.Unmarshal(rawMsg, &self.private.Items)
		case "shipping_address":
			err = json.Unmarshal(rawMsg, &self.private.ShippingAddress)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

Item struct

******************************/
func NewItem() *Item {
	return &Item{
		private: private_l7fqh7t9a3u{},
	}
}

type Item struct {
	private     private_l7fqh7t9a3u
	Quantity    int64   `json:"quantity,string"`
	Name        string  `json:"name"`
	Price       float64 `json:"price,string"`
	Tax         float64 `json:"tax,omitempty"`
	Sku         string  `json:"sku,omitempty"`
	Description string  `json:"description,omitempty"`
}

type private_l7fqh7t9a3u struct {
	Currency CurrencyTypeEnum `json:"currency"`
}

type json_l7fqh7t9a3u struct {
	*private_l7fqh7t9a3u
	Quantity    int64   `json:"quantity,string"`
	Name        string  `json:"name"`
	Price       float64 `json:"price,string"`
	Tax         float64 `json:"tax,omitempty"`
	Sku         string  `json:"sku,omitempty"`
	Description string  `json:"description,omitempty"`
}

func (self *Item) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

func (self *Item) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_l7fqh7t9a3u{
		&self.private,
		self.Quantity,
		self.Name,
		self.Price,
		self.Tax,
		self.Sku,
		self.Description,
	})
}

func (self *Item) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "currency":
			err = json.Unmarshal(rawMsg, &self.private.Currency)
		case "quantity":
			err = json.Unmarshal(rawMsg, &self.Quantity)
		case "name":
			err = json.Unmarshal(rawMsg, &self.Name)
		case "price":
			err = json.Unmarshal(rawMsg, &self.Price)
		case "tax":
			err = json.Unmarshal(rawMsg, &self.Tax)
		case "sku":
			err = json.Unmarshal(rawMsg, &self.Sku)
		case "description":
			err = json.Unmarshal(rawMsg, &self.Description)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

_shared struct

******************************/

type _shared struct {
	private private_1xjqhy6fbvv1u
	*connection
	*identity_error
}

type private_1xjqhy6fbvv1u struct {
	Id            string    `json:"id,omitempty"`
	CreateTime    dateTime  `json:"create_time,omitempty"`
	UpdateTime    dateTime  `json:"update_time,omitempty"`
	State         stateEnum `json:"state,omitempty"`
	ParentPayment string    `json:"parent_payment,omitempty"`
	Links         links     `json:"links,omitempty"`
}

type json_1xjqhy6fbvv1u struct {
	*private_1xjqhy6fbvv1u
	*connection
	*identity_error
}

func (self *_shared) Id() string {
	return self.private.Id
}

func (self *_shared) CreateTime() dateTime {
	return self.private.CreateTime
}

func (self *_shared) UpdateTime() dateTime {
	return self.private.UpdateTime
}

func (self *_shared) State() stateEnum {
	return self.private.State
}

func (self *_shared) ParentPayment() string {
	return self.private.ParentPayment
}

func (self *_shared) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1xjqhy6fbvv1u{
		&self.private,
		self.connection,
		self.identity_error,
	})
}

func (self *_shared) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "id":
			err = json.Unmarshal(rawMsg, &self.private.Id)
		case "create_time":
			err = json.Unmarshal(rawMsg, &self.private.CreateTime)
		case "update_time":
			err = json.Unmarshal(rawMsg, &self.private.UpdateTime)
		case "state":
			err = json.Unmarshal(rawMsg, &self.private.State)
		case "parent_payment":
			err = json.Unmarshal(rawMsg, &self.private.ParentPayment)
		case "links":
			err = json.Unmarshal(rawMsg, &self.private.Links)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

Authorization struct

******************************/

// State items are: pending, authorized, captured, partially_captured, expired,
// voided
type Authorization struct {
	private private_1pcje5zx903ji
	_shared
}

type private_1pcje5zx903ji struct {
	Amount             amount                 `json:"amount"`
	BillingAgreementId string                 `json:"billing_agreement_id"`
	PaymentMode        paymentModeEnum        `json:"payment_mode"`
	ReasonCode         reasonCodeEnum         `json:"reason_code"`
	ValidUntil         dateTime               `json:"valid_until"`
	ClearingTime       string                 `json:"clearing_time"`
	ProtectionElig     protectionEligEnum     `json:"protection_eligibility"`
	ProtectionEligType protectionEligTypeEnum `json:"protection_eligibility_type"`
	FmfDetails         fmfDetails             `json:"fmf_details"`
}

type json_1pcje5zx903ji struct {
	*private_1pcje5zx903ji
	_shared
}

func (self *Authorization) Amount() amount {
	return self.private.Amount
}

func (self *Authorization) BillingAgreementId() string {
	return self.private.BillingAgreementId
}

func (self *Authorization) PaymentMode() paymentModeEnum {
	return self.private.PaymentMode
}

func (self *Authorization) ReasonCode() reasonCodeEnum {
	return self.private.ReasonCode
}

func (self *Authorization) ValidUntil() dateTime {
	return self.private.ValidUntil
}

func (self *Authorization) ClearingTime() string {
	return self.private.ClearingTime
}

func (self *Authorization) ProtectionElig() protectionEligEnum {
	return self.private.ProtectionElig
}

func (self *Authorization) ProtectionEligType() protectionEligTypeEnum {
	return self.private.ProtectionEligType
}

func (self *Authorization) FmfDetails() fmfDetails {
	return self.private.FmfDetails
}

func (self *Authorization) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1pcje5zx903ji{
		&self.private,
		self._shared,
	})
}

func (self *Authorization) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "amount":
			err = json.Unmarshal(rawMsg, &self.private.Amount)
		case "billing_agreement_id":
			err = json.Unmarshal(rawMsg, &self.private.BillingAgreementId)
		case "payment_mode":
			err = json.Unmarshal(rawMsg, &self.private.PaymentMode)
		case "reason_code":
			err = json.Unmarshal(rawMsg, &self.private.ReasonCode)
		case "valid_until":
			err = json.Unmarshal(rawMsg, &self.private.ValidUntil)
		case "clearing_time":
			err = json.Unmarshal(rawMsg, &self.private.ClearingTime)
		case "protection_eligibility":
			err = json.Unmarshal(rawMsg, &self.private.ProtectionElig)
		case "protection_eligibility_type":
			err = json.Unmarshal(rawMsg, &self.private.ProtectionEligType)
		case "fmf_details":
			err = json.Unmarshal(rawMsg, &self.private.FmfDetails)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

Capture struct

******************************/
func NewCapture() *Capture {
	return &Capture{
		private: private_1kb4ofgp0ydhg{},
	}
}

// State values are: pending, completed, refunded, partially_refunded
type Capture struct {
	private private_1kb4ofgp0ydhg
	_shared
	TransactionFee currency `json:"transaction_fee"`
	IsFinalCapture bool     `json:"is_final_capture,omitempty"`
}

type private_1kb4ofgp0ydhg struct {
	Amount amount `json:"amount"`
}

type json_1kb4ofgp0ydhg struct {
	*private_1kb4ofgp0ydhg
	_shared
	TransactionFee currency `json:"transaction_fee"`
	IsFinalCapture bool     `json:"is_final_capture,omitempty"`
}

func (self *Capture) Amount() amount {
	return self.private.Amount
}

func (self *Capture) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1kb4ofgp0ydhg{
		&self.private,
		self._shared,
		self.TransactionFee,
		self.IsFinalCapture,
	})
}

func (self *Capture) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "amount":
			err = json.Unmarshal(rawMsg, &self.private.Amount)
		case "transaction_fee":
			err = json.Unmarshal(rawMsg, &self.TransactionFee)
		case "is_final_capture":
			err = json.Unmarshal(rawMsg, &self.IsFinalCapture)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

Sale struct

******************************/
func NewSale() *Sale {
	return &Sale{
		private: private_hxtwebn5e8i0{},
	}
}

// State values are: pending; completed; refunded; partially_refunded
// TODO: PendingReason appears in the old docs under the general Sale object description
// but not under the lower "sale object" definition. The new docs have it
// marked as [DEPRECATED] in one area, but not another.
type Sale struct {
	private private_hxtwebn5e8i0
	_shared
	Description      string   `json:"description,omitempty"`
	TransactionFee   currency `json:"transaction_fee"`
	ReceivableAmount currency `json:"receivable_amount"`
}

type private_hxtwebn5e8i0 struct {
	Amount                    amount                 `json:"amount"`
	PendingReason             pendingReasonEnum      `json:"pending_reason"`
	PaymentMode               paymentModeEnum        `json:"payment_mode"`
	ExchangeRate              string                 `json:"exchange_rate"`
	FmfDetails                fmfDetails             `json:"fmf_details"`
	ReceiptId                 string                 `json:"receipt_id"`
	ReasonCode                reasonCodeEnum         `json:"reason_code"`
	ProtectionEligibility     protectionEligEnum     `json:"protection_eligibility"`
	ProtectionEligibilityType protectionEligTypeEnum `json:"protection_eligibility_type"`
	ClearingTime              string                 `json:"clearing_time"`
	BillingAgreementId        string                 `json:"billing_agreement_id"`
}

type json_hxtwebn5e8i0 struct {
	*private_hxtwebn5e8i0
	_shared
	Description      string   `json:"description,omitempty"`
	TransactionFee   currency `json:"transaction_fee"`
	ReceivableAmount currency `json:"receivable_amount"`
}

func (self *Sale) Amount() amount {
	return self.private.Amount
}

func (self *Sale) PendingReason() pendingReasonEnum {
	return self.private.PendingReason
}

func (self *Sale) PaymentMode() paymentModeEnum {
	return self.private.PaymentMode
}

func (self *Sale) ExchangeRate() string {
	return self.private.ExchangeRate
}

func (self *Sale) FmfDetails() fmfDetails {
	return self.private.FmfDetails
}

func (self *Sale) ReceiptId() string {
	return self.private.ReceiptId
}

func (self *Sale) ReasonCode() reasonCodeEnum {
	return self.private.ReasonCode
}

func (self *Sale) ProtectionEligibility() protectionEligEnum {
	return self.private.ProtectionEligibility
}

func (self *Sale) ProtectionEligibilityType() protectionEligTypeEnum {
	return self.private.ProtectionEligibilityType
}

func (self *Sale) ClearingTime() string {
	return self.private.ClearingTime
}

func (self *Sale) BillingAgreementId() string {
	return self.private.BillingAgreementId
}

func (self *Sale) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_hxtwebn5e8i0{
		&self.private,
		self._shared,
		self.Description,
		self.TransactionFee,
		self.ReceivableAmount,
	})
}

func (self *Sale) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "amount":
			err = json.Unmarshal(rawMsg, &self.private.Amount)
		case "description":
			err = json.Unmarshal(rawMsg, &self.Description)
		case "transaction_fee":
			err = json.Unmarshal(rawMsg, &self.TransactionFee)
		case "receivable_amount":
			err = json.Unmarshal(rawMsg, &self.ReceivableAmount)
		case "pending_reason":
			err = json.Unmarshal(rawMsg, &self.private.PendingReason)
		case "payment_mode":
			err = json.Unmarshal(rawMsg, &self.private.PaymentMode)
		case "exchange_rate":
			err = json.Unmarshal(rawMsg, &self.private.ExchangeRate)
		case "fmf_details":
			err = json.Unmarshal(rawMsg, &self.private.FmfDetails)
		case "receipt_id":
			err = json.Unmarshal(rawMsg, &self.private.ReceiptId)
		case "reason_code":
			err = json.Unmarshal(rawMsg, &self.private.ReasonCode)
		case "protection_eligibility":
			err = json.Unmarshal(rawMsg, &self.private.ProtectionEligibility)
		case "protection_eligibility_type":
			err = json.Unmarshal(rawMsg, &self.private.ProtectionEligibilityType)
		case "clearing_time":
			err = json.Unmarshal(rawMsg, &self.private.ClearingTime)
		case "billing_agreement_id":
			err = json.Unmarshal(rawMsg, &self.private.BillingAgreementId)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

Refund struct

******************************/
func NewRefund() *Refund {
	return &Refund{
		private: private_qssug4xwj69y{},
	}
}

// State items are: pending; completed; failed
type Refund struct {
	private private_qssug4xwj69y
	_shared
	Description string `json:"description,omitempty"`
	Reason      string `json:"reason,omitempty"`
}

type private_qssug4xwj69y struct {
	Amount    amount `json:"amount"`
	SaleId    string `json:"sale_id,omitempty"`
	CaptureId string `json:"capture_id,omitempty"`
}

type json_qssug4xwj69y struct {
	*private_qssug4xwj69y
	_shared
	Description string `json:"description,omitempty"`
	Reason      string `json:"reason,omitempty"`
}

func (self *Refund) Amount() amount {
	return self.private.Amount
}

func (self *Refund) SaleId() string {
	return self.private.SaleId
}

func (self *Refund) CaptureId() string {
	return self.private.CaptureId
}

func (self *Refund) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_qssug4xwj69y{
		&self.private,
		self._shared,
		self.Description,
		self.Reason,
	})
}

func (self *Refund) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "amount":
			err = json.Unmarshal(rawMsg, &self.private.Amount)
		case "description":
			err = json.Unmarshal(rawMsg, &self.Description)
		case "reason":
			err = json.Unmarshal(rawMsg, &self.Reason)
		case "sale_id":
			err = json.Unmarshal(rawMsg, &self.private.SaleId)
		case "capture_id":
			err = json.Unmarshal(rawMsg, &self.private.CaptureId)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

amount struct

******************************/
func NewAmount() *amount {
	return &amount{
		private: private_lo5l1zb7y4{},
	}
}

// Amount Object
// A`Transaction` object also may have an `ItemList`, which has dollar amounts.
// These amounts are used to calculate the `Total` field of the `Amount` object
//
// All other uses of `Amount` do have `shipping`, `shipping_discount` and
// `subtotal` to calculate the `Total`.
type amount struct {
	private private_lo5l1zb7y4
	Details *details `json:"details,omitempty"`
}

type private_lo5l1zb7y4 struct {
	Currency CurrencyTypeEnum `json:"currency"`
	Total    float64          `json:"total"`
}

type json_lo5l1zb7y4 struct {
	*private_lo5l1zb7y4
	Details *details `json:"details,omitempty"`
}

func (self *amount) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

func (self *amount) Total() float64 {
	return self.private.Total
}

func (self *amount) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_lo5l1zb7y4{
		&self.private,
		self.Details,
	})
}

func (self *amount) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "currency":
			err = json.Unmarshal(rawMsg, &self.private.Currency)
		case "total":
			err = json.Unmarshal(rawMsg, &self.private.Total)
		case "details":
			err = json.Unmarshal(rawMsg, &self.Details)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

details struct

******************************/
func NewDetails() *details {
	return &details{
		private: private_1u63wyw7mai3g{},
	}
}

type details struct {
	private private_1u63wyw7mai3g
}

type private_1u63wyw7mai3g struct {
	// Amount charged for shipping. 10 chars max, with support for 2 decimal places
	Shipping float64 `json:"shipping,omitempty"`
	// Amount of the subtotal of the items. REQUIRED if line items are specified.
	// 10 chars max, with support for 2 decimal places
	Subtotal float64 `json:"subtotal,omitempty"`
	// Amount charged for tax. 10 chars max, with support for 2 decimal places
	Tax float64 `json:"tax,omitempty"`
	// Amount being charged for handling fee. When `payment_method` is `paypal`
	HandlingFee float64 `json:"handling_fee,omitempty"`
	// Amount being charged for insurance fee. When `payment_method` is `paypal`
	Insurance float64 `json:"insurance,omitempty"`
	// Amount being discounted for shipping fee. When `payment_method` is `paypal`
	ShippingDiscount float64 `json:"shipping_discount,omitempty"`
}

type json_1u63wyw7mai3g struct {
	*private_1u63wyw7mai3g
}

func (self *details) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1u63wyw7mai3g{
		&self.private,
	})
}

func (self *details) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "shipping":
			err = json.Unmarshal(rawMsg, &self.private.Shipping)
		case "subtotal":
			err = json.Unmarshal(rawMsg, &self.private.Subtotal)
		case "tax":
			err = json.Unmarshal(rawMsg, &self.private.Tax)
		case "handling_fee":
			err = json.Unmarshal(rawMsg, &self.private.HandlingFee)
		case "insurance":
			err = json.Unmarshal(rawMsg, &self.private.Insurance)
		case "shipping_discount":
			err = json.Unmarshal(rawMsg, &self.private.ShippingDiscount)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

link struct

******************************/
func NewLink() *link {
	return &link{
		private: private_mcvrtyg5sx4k{},
	}
}

type link struct {
	private private_mcvrtyg5sx4k
}

type private_mcvrtyg5sx4k struct {
	Href   string      `json:"href,omitempty"`
	Rel    relTypeEnum `json:"rel,omitempty"`
	Method string      `json:"method,omitempty"`
}

type json_mcvrtyg5sx4k struct {
	*private_mcvrtyg5sx4k
}

func (self *link) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_mcvrtyg5sx4k{
		&self.private,
	})
}

func (self *link) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "href":
			err = json.Unmarshal(rawMsg, &self.private.Href)
		case "rel":
			err = json.Unmarshal(rawMsg, &self.private.Rel)
		case "method":
			err = json.Unmarshal(rawMsg, &self.private.Method)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

currency struct

******************************/
func NewCurrency() *currency {
	return &currency{
		private: private_1oxdopanqft4q{},
	}
}

// Base object for all financial value related fields (balance, payment due, etc.)
type currency struct {
	private  private_1oxdopanqft4q
	Currency string `json:"currency"`
	Value    string `json:"value"`
}

type private_1oxdopanqft4q struct{}

type json_1oxdopanqft4q struct {
	*private_1oxdopanqft4q
	Currency string `json:"currency"`
	Value    string `json:"value"`
}

func (self *currency) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1oxdopanqft4q{
		&self.private,
		self.Currency,
		self.Value,
	})
}

func (self *currency) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "currency":
			err = json.Unmarshal(rawMsg, &self.Currency)
		case "value":
			err = json.Unmarshal(rawMsg, &self.Value)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

fmfDetails struct

******************************/
func NewFmfDetails() *fmfDetails {
	return &fmfDetails{
		private: private_p034inv0y2nf{},
	}
}

// This object represents Fraud Management Filter (FMF) details for a payment.
type fmfDetails struct {
	private private_p034inv0y2nf
}

type private_p034inv0y2nf struct {
	FilterType  fmfFilterEnum `json:"filter_type"`
	FilterID    filterIdEnum  `json:"filter_id"`
	Name        string        `json:"name"`
	Description string        `json:"description"`
}

type json_p034inv0y2nf struct {
	*private_p034inv0y2nf
}

func (self *fmfDetails) FilterType() fmfFilterEnum {
	return self.private.FilterType
}

func (self *fmfDetails) FilterID() filterIdEnum {
	return self.private.FilterID
}

func (self *fmfDetails) Name() string {
	return self.private.Name
}

func (self *fmfDetails) Description() string {
	return self.private.Description
}

func (self *fmfDetails) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_p034inv0y2nf{
		&self.private,
	})
}

func (self *fmfDetails) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "filter_type":
			err = json.Unmarshal(rawMsg, &self.private.FilterType)
		case "filter_id":
			err = json.Unmarshal(rawMsg, &self.private.FilterID)
		case "name":
			err = json.Unmarshal(rawMsg, &self.private.Name)
		case "description":
			err = json.Unmarshal(rawMsg, &self.private.Description)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

payer struct

******************************/
func NewPayer() *payer {
	return &payer{
		private: private_uz0fu5s077ij{},
	}
}

// Source of the funds for this payment represented by a PayPal account or a
// credit card.
type payer struct {
	private private_uz0fu5s077ij
}

type private_uz0fu5s077ij struct {
	PaymentMethod      PaymentMethodEnum  `json:"payment_method,omitempty"`
	Status             payerStatusEnum    `json:"status,omitempty"`
	FundingInstruments fundingInstruments `json:"funding_instruments,omitempty"`
	PayerInfo          *PayerInfo         `json:"payer_info,omitempty"`
}

type json_uz0fu5s077ij struct {
	*private_uz0fu5s077ij
}

func (self *payer) PaymentMethod() PaymentMethodEnum {
	return self.private.PaymentMethod
}

func (self *payer) Status() payerStatusEnum {
	return self.private.Status
}

func (self *payer) FundingInstruments() fundingInstruments {
	return self.private.FundingInstruments
}

func (self *payer) PayerInfo() *PayerInfo {
	return self.private.PayerInfo
}

func (self *payer) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_uz0fu5s077ij{
		&self.private,
	})
}

func (self *payer) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "payment_method":
			err = json.Unmarshal(rawMsg, &self.private.PaymentMethod)
		case "status":
			err = json.Unmarshal(rawMsg, &self.private.Status)
		case "funding_instruments":
			err = json.Unmarshal(rawMsg, &self.private.FundingInstruments)
		case "payer_info":
			err = json.Unmarshal(rawMsg, &self.private.PayerInfo)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

PayerInfo struct

******************************/
func NewPayerInfo() *PayerInfo {
	return &PayerInfo{
		private: private_1jg508kopx06e{},
	}
}

// TODO: This is used both for Paypal and Credit cards. In the case of Paypal,
// many (most) of the fields may not be included in a requrest. Should we have
// a separate `PaypalPayerInfo` object? It could be embedded into the main
// `PayerInfo` object.
// This object is pre-filled by PayPal when the payment_method is paypal.
type PayerInfo struct {
	private private_1jg508kopx06e
	// Email address representing the payer. 127 characters max.
	Email string `json:"email,omitempty"`
	// Salutation of the payer.
	Salutation string `json:"salutation,omitempty"`
	// Suffix of the payer.
	Suffix string `json:"suffix,omitempty"`
	// Two-letter registered country code of the payer to identify the buyer country.
	CountryCode CountryCodeEnum `json:"country_code,omitempty"`
	// Phone number representing the payer. 20 characters max.
	Phone string `json:"phone,omitempty"`
	// Payer’s tax ID type. Allowed values: BR_CPF or BR_CNPJ. Only supported when
	// the payment_method is set to paypal.
	TaxIdType TaxIdTypeEnum `json:"tax_id_type,omitempty"`
	// Payer’s tax ID. Only supported when the payment_method is set to paypal.
	TaxId string `json:"tax_id,omitempty"`
}

type private_1jg508kopx06e struct {
	// First name of the payer. Value assigned by PayPal.
	FirstName string `json:"first_name,omitempty"`
	// Middle name of the payer. Value assigned by PayPal.
	MiddleName string `json:"middle_name,omitempty"`
	// Last name of the payer. Value assigned by PayPal.
	LastName string `json:"last_name,omitempty"`
	// PayPal assigned Payer ID. Value assigned by PayPal.
	PayerId string `json:"payer_id,omitempty"`
	// Shipping address of payer PayPal account. Value assigned by PayPal.
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

type json_1jg508kopx06e struct {
	*private_1jg508kopx06e
	Email       string          `json:"email,omitempty"`
	Salutation  string          `json:"salutation,omitempty"`
	Suffix      string          `json:"suffix,omitempty"`
	CountryCode CountryCodeEnum `json:"country_code,omitempty"`
	Phone       string          `json:"phone,omitempty"`
	TaxIdType   TaxIdTypeEnum   `json:"tax_id_type,omitempty"`
	TaxId       string          `json:"tax_id,omitempty"`
}

func (self *PayerInfo) FirstName() string {
	return self.private.FirstName
}

func (self *PayerInfo) MiddleName() string {
	return self.private.MiddleName
}

func (self *PayerInfo) LastName() string {
	return self.private.LastName
}

func (self *PayerInfo) PayerId() string {
	return self.private.PayerId
}

func (self *PayerInfo) ShippingAddress() *ShippingAddress {
	return self.private.ShippingAddress
}

func (self *PayerInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1jg508kopx06e{
		&self.private,
		self.Email,
		self.Salutation,
		self.Suffix,
		self.CountryCode,
		self.Phone,
		self.TaxIdType,
		self.TaxId,
	})
}

func (self *PayerInfo) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "email":
			err = json.Unmarshal(rawMsg, &self.Email)
		case "salutation":
			err = json.Unmarshal(rawMsg, &self.Salutation)
		case "suffix":
			err = json.Unmarshal(rawMsg, &self.Suffix)
		case "country_code":
			err = json.Unmarshal(rawMsg, &self.CountryCode)
		case "phone":
			err = json.Unmarshal(rawMsg, &self.Phone)
		case "tax_id_type":
			err = json.Unmarshal(rawMsg, &self.TaxIdType)
		case "tax_id":
			err = json.Unmarshal(rawMsg, &self.TaxId)
		case "first_name":
			err = json.Unmarshal(rawMsg, &self.private.FirstName)
		case "middle_name":
			err = json.Unmarshal(rawMsg, &self.private.MiddleName)
		case "last_name":
			err = json.Unmarshal(rawMsg, &self.private.LastName)
		case "payer_id":
			err = json.Unmarshal(rawMsg, &self.private.PayerId)
		case "shipping_address":
			err = json.Unmarshal(rawMsg, &self.private.ShippingAddress)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}
