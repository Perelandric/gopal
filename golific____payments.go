/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"Golific/gJson"
	"encoding/json"
	"strings"
)

/*****************************

CreditCardItem struct

******************************/

type CreditCardItem struct {
	private  private_16k05qi3obm5r
	Quantity int64   `json:"quantity,string"`
	Name     string  `json:"name"`
	Price    float64 `json:"price,string"`
	Sku      string  `json:"sku,omitempty"`
	Url      string  `json:"url,omitempty"`
}

type private_16k05qi3obm5r struct {
	Currency CurrencyTypeEnum `json:"currency"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_16k05qi3obm5r) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("currency", self.Currency, first)
	first = false
}

type json_16k05qi3obm5r struct {
	*private_16k05qi3obm5r
	Quantity int64   `json:"quantity,string"`
	Name     string  `json:"name"`
	Price    float64 `json:"price,string"`
	Sku      string  `json:"sku,omitempty"`
	Url      string  `json:"url,omitempty"`
}

func (self *CreditCardItem) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *CreditCardItem) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	encoder.EncodeKeyVal("quantity", self.Quantity, first)
	first = false

	encoder.EncodeKeyVal("name", self.Name, first)
	first = false

	encoder.EncodeKeyVal("price", self.Price, first)
	first = false

	if len(self.Sku) != 0 {
		encoder.EncodeKeyVal("sku", self.Sku, first)
		first = false
	}

	if len(self.Url) != 0 {
		encoder.EncodeKeyVal("url", self.Url, first)
		first = false
	}
	encoder.WriteRawByte('}')
}

func (self *CreditCardItem) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_16k05qi3obm5r{
		&self.private,
		self.Quantity,
		self.Name,
		self.Price,
		self.Sku,
		self.Url,
	})
}

func (self *CreditCardItem) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["currency"]; ok {
		if err = json.Unmarshal(data, &self.private.Currency); err != nil {
			return err
		}
	}

	if data, ok = m["quantity"]; ok {
		if err = json.Unmarshal(data, &self.Quantity); err != nil {
			return err
		}
	}

	if data, ok = m["name"]; ok {
		if err = json.Unmarshal(data, &self.Name); err != nil {
			return err
		}
	}

	if data, ok = m["price"]; ok {
		if err = json.Unmarshal(data, &self.Price); err != nil {
			return err
		}
	}

	if data, ok = m["sku"]; ok {
		if err = json.Unmarshal(data, &self.Sku); err != nil {
			return err
		}
	}

	if data, ok = m["url"]; ok {
		if err = json.Unmarshal(data, &self.Url); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

PaypalItem struct

******************************/

type PaypalItem struct {
	private     private_jznylr5xuqt6
	Quantity    int64   `json:"quantity,string"`
	Name        string  `json:"name"`
	Price       float64 `json:"price,string"`
	Sku         string  `json:"sku,omitempty"`
	Url         string  `json:"url,omitempty"`
	Tax         float64 `json:"tax,string,omitempty"`
	Description string  `json:"description,omitempty"`
}

type private_jznylr5xuqt6 struct {
	Currency CurrencyTypeEnum `json:"currency"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_jznylr5xuqt6) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("currency", self.Currency, first)
	first = false
}

type json_jznylr5xuqt6 struct {
	*private_jznylr5xuqt6
	Quantity    int64   `json:"quantity,string"`
	Name        string  `json:"name"`
	Price       float64 `json:"price,string"`
	Sku         string  `json:"sku,omitempty"`
	Url         string  `json:"url,omitempty"`
	Tax         float64 `json:"tax,string,omitempty"`
	Description string  `json:"description,omitempty"`
}

func (self *PaypalItem) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *PaypalItem) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	encoder.EncodeKeyVal("quantity", self.Quantity, first)
	first = false

	encoder.EncodeKeyVal("name", self.Name, first)
	first = false

	encoder.EncodeKeyVal("price", self.Price, first)
	first = false

	if len(self.Sku) != 0 {
		encoder.EncodeKeyVal("sku", self.Sku, first)
		first = false
	}

	if len(self.Url) != 0 {
		encoder.EncodeKeyVal("url", self.Url, first)
		first = false
	}

	if self.Tax != 0 {
		encoder.EncodeKeyVal("tax", self.Tax, first)
		first = false
	}

	if len(self.Description) != 0 {
		encoder.EncodeKeyVal("description", self.Description, first)
		first = false
	}
	encoder.WriteRawByte('}')
}

func (self *PaypalItem) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_jznylr5xuqt6{
		&self.private,
		self.Quantity,
		self.Name,
		self.Price,
		self.Sku,
		self.Url,
		self.Tax,
		self.Description,
	})
}

func (self *PaypalItem) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["currency"]; ok {
		if err = json.Unmarshal(data, &self.private.Currency); err != nil {
			return err
		}
	}

	if data, ok = m["quantity"]; ok {
		if err = json.Unmarshal(data, &self.Quantity); err != nil {
			return err
		}
	}

	if data, ok = m["name"]; ok {
		if err = json.Unmarshal(data, &self.Name); err != nil {
			return err
		}
	}

	if data, ok = m["price"]; ok {
		if err = json.Unmarshal(data, &self.Price); err != nil {
			return err
		}
	}

	if data, ok = m["sku"]; ok {
		if err = json.Unmarshal(data, &self.Sku); err != nil {
			return err
		}
	}

	if data, ok = m["url"]; ok {
		if err = json.Unmarshal(data, &self.Url); err != nil {
			return err
		}
	}

	if data, ok = m["tax"]; ok {
		if err = json.Unmarshal(data, &self.Tax); err != nil {
			return err
		}
	}

	if data, ok = m["description"]; ok {
		if err = json.Unmarshal(data, &self.Description); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

_shared struct

******************************/

type _shared struct {
	private private_r7jy33uq2cdf
	*connection
	*identity_error
}

type private_r7jy33uq2cdf struct {
	Id            string    `json:"id,omitempty"`
	CreateTime    dateTime  `json:"create_time,omitempty"`
	UpdateTime    dateTime  `json:"update_time,omitempty"`
	State         StateEnum `json:"state,omitempty"`
	ParentPayment string    `json:"parent_payment,omitempty"`
	Links         links     `json:"links,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_r7jy33uq2cdf) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	if len(self.Id) != 0 {
		encoder.EncodeKeyVal("id", self.Id, first)
		first = false
	}

	encoder.EncodeKeyVal("create_time", self.CreateTime, first)
	first = false

	encoder.EncodeKeyVal("update_time", self.UpdateTime, first)
	first = false

	encoder.EncodeKeyVal("state", self.State, first)
	first = false

	if len(self.ParentPayment) != 0 {
		encoder.EncodeKeyVal("parent_payment", self.ParentPayment, first)
		first = false
	}

	encoder.EncodeKeyVal("links", self.Links, first)
	first = false
}

type json_r7jy33uq2cdf struct {
	*private_r7jy33uq2cdf
	*connection
	*identity_error
}

func (self *_shared) Id() string {
	return self.private.Id
}

func (self *_shared) CreateTime() dateTime {
	return self.private.CreateTime
}

func (self *_shared) UpdateTime() dateTime {
	return self.private.UpdateTime
}

func (self *_shared) State() StateEnum {
	return self.private.State
}

func (self *_shared) ParentPayment() string {
	return self.private.ParentPayment
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *_shared) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	if je, ok := interface{}(self.connection).(gJson.JSONEncodable); ok {
		first = encoder.EmbedEncodedStruct(je, first)
	} else {
		first = encoder.EmbedMarshaledStruct(self.connection, first)
	}

	if je, ok := interface{}(self.identity_error).(gJson.JSONEncodable); ok {
		first = encoder.EmbedEncodedStruct(je, first)
	} else {
		first = encoder.EmbedMarshaledStruct(self.identity_error, first)
	}

	encoder.WriteRawByte('}')
}

func (self *_shared) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_r7jy33uq2cdf{
		&self.private,
		self.connection,
		self.identity_error,
	})
}

func (self *_shared) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["id"]; ok {
		if err = json.Unmarshal(data, &self.private.Id); err != nil {
			return err
		}
	}

	if data, ok = m["create_time"]; ok {
		if err = json.Unmarshal(data, &self.private.CreateTime); err != nil {
			return err
		}
	}

	if data, ok = m["update_time"]; ok {
		if err = json.Unmarshal(data, &self.private.UpdateTime); err != nil {
			return err
		}
	}

	if data, ok = m["state"]; ok {
		if err = json.Unmarshal(data, &self.private.State); err != nil {
			return err
		}
	}

	if data, ok = m["parent_payment"]; ok {
		if err = json.Unmarshal(data, &self.private.ParentPayment); err != nil {
			return err
		}
	}

	if data, ok = m["links"]; ok {
		if err = json.Unmarshal(data, &self.private.Links); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

amount struct

******************************/

// Amount Object
//  A `Transaction` object also may have an `ItemList`, which has dollar amounts.
//  These amounts are used to calculate the `Total` field of the `Amount` object
//
//	All other uses of `Amount` do have `shipping`, `shipping_discount` and
// `subtotal` to calculate the `Total`.
type amount struct {
	private private_1j8jmse5dn3zd
	Details *details `json:"details,omitempty"`
}

type private_1j8jmse5dn3zd struct {
	Currency CurrencyTypeEnum `json:"currency"`
	Total    float64          `json:"total,string"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1j8jmse5dn3zd) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("currency", self.Currency, first)
	first = false

	encoder.EncodeKeyVal("total", self.Total, first)
	first = false
}

type json_1j8jmse5dn3zd struct {
	*private_1j8jmse5dn3zd
	Details *details `json:"details,omitempty"`
}

func (self *amount) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

func (self *amount) Total() float64 {
	return self.private.Total
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *amount) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	if z, ok := interface{}(self.Details).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("details", self.Details, first)
		first = false
	}
	encoder.WriteRawByte('}')
}

func (self *amount) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1j8jmse5dn3zd{
		&self.private,
		self.Details,
	})
}

func (self *amount) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["currency"]; ok {
		if err = json.Unmarshal(data, &self.private.Currency); err != nil {
			return err
		}
	}

	if data, ok = m["total"]; ok {
		if err = json.Unmarshal(data, &self.private.Total); err != nil {
			return err
		}
	}

	if data, ok = m["details"]; ok {
		if err = json.Unmarshal(data, &self.Details); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

details struct

******************************/

// The Details can all be read/write because the Amount object is read only,
// so it gets a copy anyway.
// No need to validate because its values are calculated or validated when set.
type details struct {
	private private_1dtod2xzjz3wc
	// Amount charged for shipping. 10 chars max, with support for 2 decimal places
	Shipping float64 `json:"shipping,string,omitempty"`
	// Amount being charged for handling fee. When `payment_method` is `paypal`
	HandlingFee float64 `json:"handling_fee,string,omitempty"`
	// Amount being charged for insurance fee. When `payment_method` is `paypal`
	Insurance float64 `json:"insurance,string,omitempty"`
	// Amount being discounted for shipping fee. When `payment_method` is `paypal`
	ShippingDiscount float64 `json:"shipping_discount,string,omitempty"`
}

type private_1dtod2xzjz3wc struct {
	// Amount of the subtotal of the items. REQUIRED if line items are specified.
	// 10 chars max, with support for 2 decimal places
	Subtotal float64 `json:"subtotal,string,omitempty"`
	// Amount charged for tax. 10 chars max, with support for 2 decimal places
	Tax float64 `json:"tax,string,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1dtod2xzjz3wc) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	if self.Subtotal != 0 {
		encoder.EncodeKeyVal("subtotal", self.Subtotal, first)
		first = false
	}

	if self.Tax != 0 {
		encoder.EncodeKeyVal("tax", self.Tax, first)
		first = false
	}
}

type json_1dtod2xzjz3wc struct {
	*private_1dtod2xzjz3wc
	Shipping         float64 `json:"shipping,string,omitempty"`
	HandlingFee      float64 `json:"handling_fee,string,omitempty"`
	Insurance        float64 `json:"insurance,string,omitempty"`
	ShippingDiscount float64 `json:"shipping_discount,string,omitempty"`
}

func (self *details) Subtotal() float64 {
	return self.private.Subtotal
}

func (self *details) Tax() float64 {
	return self.private.Tax
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *details) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	if self.Shipping != 0 {
		encoder.EncodeKeyVal("shipping", self.Shipping, first)
		first = false
	}

	if self.HandlingFee != 0 {
		encoder.EncodeKeyVal("handling_fee", self.HandlingFee, first)
		first = false
	}

	if self.Insurance != 0 {
		encoder.EncodeKeyVal("insurance", self.Insurance, first)
		first = false
	}

	if self.ShippingDiscount != 0 {
		encoder.EncodeKeyVal("shipping_discount", self.ShippingDiscount, first)
		first = false
	}
	encoder.WriteRawByte('}')
}

func (self *details) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1dtod2xzjz3wc{
		&self.private,
		self.Shipping,
		self.HandlingFee,
		self.Insurance,
		self.ShippingDiscount,
	})
}

func (self *details) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["subtotal"]; ok {
		if err = json.Unmarshal(data, &self.private.Subtotal); err != nil {
			return err
		}
	}

	if data, ok = m["tax"]; ok {
		if err = json.Unmarshal(data, &self.private.Tax); err != nil {
			return err
		}
	}

	if data, ok = m["shipping"]; ok {
		if err = json.Unmarshal(data, &self.Shipping); err != nil {
			return err
		}
	}

	if data, ok = m["handling_fee"]; ok {
		if err = json.Unmarshal(data, &self.HandlingFee); err != nil {
			return err
		}
	}

	if data, ok = m["insurance"]; ok {
		if err = json.Unmarshal(data, &self.Insurance); err != nil {
			return err
		}
	}

	if data, ok = m["shipping_discount"]; ok {
		if err = json.Unmarshal(data, &self.ShippingDiscount); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

link struct

******************************/

type link struct {
	private private_1ku4tueprsjx3
}

type private_1ku4tueprsjx3 struct {
	Href   string      `json:"href,omitempty"`
	Rel    relTypeEnum `json:"rel,omitempty"`
	Method string      `json:"method,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1ku4tueprsjx3) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	if len(self.Href) != 0 {
		encoder.EncodeKeyVal("href", self.Href, first)
		first = false
	}

	encoder.EncodeKeyVal("rel", self.Rel, first)
	first = false

	if len(self.Method) != 0 {
		encoder.EncodeKeyVal("method", self.Method, first)
		first = false
	}
}

type json_1ku4tueprsjx3 struct {
	*private_1ku4tueprsjx3
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *link) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	encoder.WriteRawByte('}')
}

func (self *link) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1ku4tueprsjx3{
		&self.private,
	})
}

func (self *link) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["href"]; ok {
		if err = json.Unmarshal(data, &self.private.Href); err != nil {
			return err
		}
	}

	if data, ok = m["rel"]; ok {
		if err = json.Unmarshal(data, &self.private.Rel); err != nil {
			return err
		}
	}

	if data, ok = m["method"]; ok {
		if err = json.Unmarshal(data, &self.private.Method); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

currency struct

******************************/

// Base object for all financial value related fields (balance, payment due, etc.)
type currency struct {
	private  private_om4ykgyb3y0x
	Currency string `json:"currency"`
	Value    string `json:"value"`
}

type private_om4ykgyb3y0x struct{}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_om4ykgyb3y0x) JSONEncode(encoder *gJson.Encoder) {}

type json_om4ykgyb3y0x struct {
	*private_om4ykgyb3y0x
	Currency string `json:"currency"`
	Value    string `json:"value"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *currency) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var first = true

	encoder.EncodeKeyVal("currency", self.Currency, first)
	first = false

	encoder.EncodeKeyVal("value", self.Value, first)
	first = false
	encoder.WriteRawByte('}')
}

func (self *currency) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_om4ykgyb3y0x{
		&self.private,
		self.Currency,
		self.Value,
	})
}

func (self *currency) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["currency"]; ok {
		if err = json.Unmarshal(data, &self.Currency); err != nil {
			return err
		}
	}

	if data, ok = m["value"]; ok {
		if err = json.Unmarshal(data, &self.Value); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

fmfDetails struct

******************************/

// This object represents Fraud Management Filter (FMF) details for a payment.
type fmfDetails struct {
	private private_1c7pa8ttumin1
}

type private_1c7pa8ttumin1 struct {
	FilterType  fmfFilterEnum `json:"filter_type"`
	FilterID    filterIdEnum  `json:"filter_id"`
	Name        string        `json:"name"`
	Description string        `json:"description"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1c7pa8ttumin1) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("filter_type", self.FilterType, first)
	first = false

	encoder.EncodeKeyVal("filter_id", self.FilterID, first)
	first = false

	encoder.EncodeKeyVal("name", self.Name, first)
	first = false

	encoder.EncodeKeyVal("description", self.Description, first)
	first = false
}

type json_1c7pa8ttumin1 struct {
	*private_1c7pa8ttumin1
}

func (self *fmfDetails) FilterType() fmfFilterEnum {
	return self.private.FilterType
}

func (self *fmfDetails) FilterID() filterIdEnum {
	return self.private.FilterID
}

func (self *fmfDetails) Name() string {
	return self.private.Name
}

func (self *fmfDetails) Description() string {
	return self.private.Description
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *fmfDetails) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	encoder.WriteRawByte('}')
}

func (self *fmfDetails) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1c7pa8ttumin1{
		&self.private,
	})
}

func (self *fmfDetails) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["filter_type"]; ok {
		if err = json.Unmarshal(data, &self.private.FilterType); err != nil {
			return err
		}
	}

	if data, ok = m["filter_id"]; ok {
		if err = json.Unmarshal(data, &self.private.FilterID); err != nil {
			return err
		}
	}

	if data, ok = m["name"]; ok {
		if err = json.Unmarshal(data, &self.private.Name); err != nil {
			return err
		}
	}

	if data, ok = m["description"]; ok {
		if err = json.Unmarshal(data, &self.private.Description); err != nil {
			return err
		}
	}
	return nil
}
