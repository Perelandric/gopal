/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"Golific/gJson"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
)

/*****************************

CreditCardItem struct

******************************/

type CreditCardItem struct {
	private  private_o6f2u1r3orv2
	Quantity int64   `json:"quantity"`
	Name     string  `json:"name"`
	Price    float64 `json:"price,string"`
	Sku      string  `json:"sku,omitempty"`
	Url      string  `json:"url,omitempty"`
}
type private_o6f2u1r3orv2 struct {
	Currency CurrencyTypeEnum `json:"currency"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_o6f2u1r3orv2) JSONEncode(encoder *gJson.Encoder) bool {
	var first = true

	if true {
		var d interface{}

		if true && reflect.ValueOf(self.Currency).Kind() == reflect.Struct {
			d = &self.Currency
		} else {
			d = self.Currency
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("currency", d, first, false) && first
		}
	}

	return !first
}

type json_o6f2u1r3orv2 struct {
	*private_o6f2u1r3orv2

	Quantity int64   `json:"quantity"`
	Name     string  `json:"name"`
	Price    float64 `json:"price,string"`
	Sku      string  `json:"sku,omitempty"`
	Url      string  `json:"url,omitempty"`
}

func (self *CreditCardItem) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *CreditCardItem) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	var first = !self.private.JSONEncode(encoder)

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Quantity).Kind() == reflect.Struct {
			d = &self.Quantity
		} else {
			d = self.Quantity
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("quantity", d, first, false) && first
		}
	}

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Name).Kind() == reflect.Struct {
			d = &self.Name
		} else {
			d = self.Name
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("name", d, first, false) && first
		}
	}

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Price).Kind() == reflect.Struct {
			d = &self.Price
		} else {
			d = self.Price
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("price", d, first, false) && first
		}
	}

	if len(self.Sku) != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Sku).Kind() == reflect.Struct {
			d = &self.Sku
		} else {
			d = self.Sku
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("sku", d, first, true) && first
		}
	}

	if len(self.Url) != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Url).Kind() == reflect.Struct {
			d = &self.Url
		} else {
			d = self.Url
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("url", d, first, true) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *CreditCardItem) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_o6f2u1r3orv2{

		&self.private,
		self.Quantity,
		self.Name,
		self.Price,
		self.Sku,
		self.Url,
	})
}

func (self *CreditCardItem) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["currency"]; ok {
		var temp struct {
			Currency CurrencyTypeEnum `json:"currency"`
		}
		data = append(append([]byte("{ \"currency\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "currency", err.Error(),
			)
		}

		self.private.Currency = temp.Currency
	}

	if data, ok = m["quantity"]; ok {
		var temp struct {
			Quantity int64 `json:"quantity"`
		}
		data = append(append([]byte("{ \"quantity\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "quantity", err.Error(),
			)
		}

		self.Quantity = temp.Quantity
	}

	if data, ok = m["name"]; ok {
		var temp struct {
			Name string `json:"name"`
		}
		data = append(append([]byte("{ \"name\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "name", err.Error(),
			)
		}

		self.Name = temp.Name
	}

	if data, ok = m["price"]; ok {
		var temp struct {
			Price float64 `json:"price,string"`
		}
		data = append(append([]byte("{ \"price\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "price", err.Error(),
			)
		}

		self.Price = temp.Price
	}

	if data, ok = m["sku"]; ok {
		var temp struct {
			Sku string `json:"sku,omitempty"`
		}
		data = append(append([]byte("{ \"sku\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "sku", err.Error(),
			)
		}

		self.Sku = temp.Sku
	}

	if data, ok = m["url"]; ok {
		var temp struct {
			Url string `json:"url,omitempty"`
		}
		data = append(append([]byte("{ \"url\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "url", err.Error(),
			)
		}

		self.Url = temp.Url
	}
	return nil
}

/*****************************

PaypalItem struct

******************************/

type PaypalItem struct {
	private     private_11vitihjemav7
	Quantity    int64   `json:"quantity"`
	Name        string  `json:"name"`
	Price       float64 `json:"price,string"`
	Sku         string  `json:"sku,omitempty"`
	Url         string  `json:"url,omitempty"`
	Tax         float64 `json:"tax,string,omitempty"`
	Description string  `json:"description,omitempty"`
}
type private_11vitihjemav7 struct {
	Currency CurrencyTypeEnum `json:"currency"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_11vitihjemav7) JSONEncode(encoder *gJson.Encoder) bool {
	var first = true

	if true {
		var d interface{}

		if true && reflect.ValueOf(self.Currency).Kind() == reflect.Struct {
			d = &self.Currency
		} else {
			d = self.Currency
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("currency", d, first, false) && first
		}
	}

	return !first
}

type json_11vitihjemav7 struct {
	*private_11vitihjemav7

	Quantity    int64   `json:"quantity"`
	Name        string  `json:"name"`
	Price       float64 `json:"price,string"`
	Sku         string  `json:"sku,omitempty"`
	Url         string  `json:"url,omitempty"`
	Tax         float64 `json:"tax,string,omitempty"`
	Description string  `json:"description,omitempty"`
}

func (self *PaypalItem) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *PaypalItem) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	var first = !self.private.JSONEncode(encoder)

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Quantity).Kind() == reflect.Struct {
			d = &self.Quantity
		} else {
			d = self.Quantity
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("quantity", d, first, false) && first
		}
	}

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Name).Kind() == reflect.Struct {
			d = &self.Name
		} else {
			d = self.Name
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("name", d, first, false) && first
		}
	}

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Price).Kind() == reflect.Struct {
			d = &self.Price
		} else {
			d = self.Price
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("price", d, first, false) && first
		}
	}

	if len(self.Sku) != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Sku).Kind() == reflect.Struct {
			d = &self.Sku
		} else {
			d = self.Sku
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("sku", d, first, true) && first
		}
	}

	if len(self.Url) != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Url).Kind() == reflect.Struct {
			d = &self.Url
		} else {
			d = self.Url
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("url", d, first, true) && first
		}
	}

	if self.Tax != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Tax).Kind() == reflect.Struct {
			d = &self.Tax
		} else {
			d = self.Tax
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("tax", d, first, true) && first
		}
	}

	if len(self.Description) != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Description).Kind() == reflect.Struct {
			d = &self.Description
		} else {
			d = self.Description
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("description", d, first, true) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *PaypalItem) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_11vitihjemav7{

		&self.private,
		self.Quantity,
		self.Name,
		self.Price,
		self.Sku,
		self.Url,
		self.Tax,
		self.Description,
	})
}

func (self *PaypalItem) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["currency"]; ok {
		var temp struct {
			Currency CurrencyTypeEnum `json:"currency"`
		}
		data = append(append([]byte("{ \"currency\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "currency", err.Error(),
			)
		}

		self.private.Currency = temp.Currency
	}

	if data, ok = m["quantity"]; ok {
		var temp struct {
			Quantity int64 `json:"quantity"`
		}
		data = append(append([]byte("{ \"quantity\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "quantity", err.Error(),
			)
		}

		self.Quantity = temp.Quantity
	}

	if data, ok = m["name"]; ok {
		var temp struct {
			Name string `json:"name"`
		}
		data = append(append([]byte("{ \"name\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "name", err.Error(),
			)
		}

		self.Name = temp.Name
	}

	if data, ok = m["price"]; ok {
		var temp struct {
			Price float64 `json:"price,string"`
		}
		data = append(append([]byte("{ \"price\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "price", err.Error(),
			)
		}

		self.Price = temp.Price
	}

	if data, ok = m["sku"]; ok {
		var temp struct {
			Sku string `json:"sku,omitempty"`
		}
		data = append(append([]byte("{ \"sku\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "sku", err.Error(),
			)
		}

		self.Sku = temp.Sku
	}

	if data, ok = m["url"]; ok {
		var temp struct {
			Url string `json:"url,omitempty"`
		}
		data = append(append([]byte("{ \"url\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "url", err.Error(),
			)
		}

		self.Url = temp.Url
	}

	if data, ok = m["tax"]; ok {
		var temp struct {
			Tax float64 `json:"tax,string,omitempty"`
		}
		data = append(append([]byte("{ \"tax\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "tax", err.Error(),
			)
		}

		self.Tax = temp.Tax
	}

	if data, ok = m["description"]; ok {
		var temp struct {
			Description string `json:"description,omitempty"`
		}
		data = append(append([]byte("{ \"description\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "description", err.Error(),
			)
		}

		self.Description = temp.Description
	}
	return nil
}

/*****************************

_shared struct

******************************/

type _shared struct {
	private private_1carno17nf4pt
	*connection
	*identity_error
}
type private_1carno17nf4pt struct {
	Id            string    `json:"id,omitempty"`
	CreateTime    dateTime  `json:"create_time,omitempty"`
	UpdateTime    dateTime  `json:"update_time,omitempty"`
	State         StateEnum `json:"state,omitempty"`
	ParentPayment string    `json:"parent_payment,omitempty"`
	Links         links     `json:"links,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1carno17nf4pt) JSONEncode(encoder *gJson.Encoder) bool {
	var first = true

	if len(self.Id) != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Id).Kind() == reflect.Struct {
			d = &self.Id
		} else {
			d = self.Id
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("id", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.CreateTime).(gJson.Elidable); !ok || !z.CanElide() {
		var d interface{}

		if true && reflect.ValueOf(self.CreateTime).Kind() == reflect.Struct {
			d = &self.CreateTime
		} else {
			d = self.CreateTime
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("create_time", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.UpdateTime).(gJson.Elidable); !ok || !z.CanElide() {
		var d interface{}

		if true && reflect.ValueOf(self.UpdateTime).Kind() == reflect.Struct {
			d = &self.UpdateTime
		} else {
			d = self.UpdateTime
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("update_time", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.State).(gJson.Elidable); !ok || !z.CanElide() {
		var d interface{}

		if true && reflect.ValueOf(self.State).Kind() == reflect.Struct {
			d = &self.State
		} else {
			d = self.State
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("state", d, first, true) && first
		}
	}

	if len(self.ParentPayment) != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.ParentPayment).Kind() == reflect.Struct {
			d = &self.ParentPayment
		} else {
			d = self.ParentPayment
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("parent_payment", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.Links).(gJson.Elidable); !ok || !z.CanElide() {
		var d interface{}

		if true && reflect.ValueOf(self.Links).Kind() == reflect.Struct {
			d = &self.Links
		} else {
			d = self.Links
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("links", d, first, true) && first
		}
	}

	return !first
}

type json_1carno17nf4pt struct {
	*private_1carno17nf4pt

	*connection
	*identity_error
}

func (self *_shared) Id() string {
	return self.private.Id
}

func (self *_shared) CreateTime() dateTime {
	return self.private.CreateTime
}

func (self *_shared) UpdateTime() dateTime {
	return self.private.UpdateTime
}

func (self *_shared) State() StateEnum {
	return self.private.State
}

func (self *_shared) ParentPayment() string {
	return self.private.ParentPayment
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *_shared) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	var first = !self.private.JSONEncode(encoder)

	if je, ok := interface{}(self.connection).(gJson.JSONEncodable); ok {
		first = !encoder.EmbedEncodedStruct(je, first) && first
	} else {
		first = !encoder.EmbedMarshaledStruct(self.connection, first) && first
	}

	if je, ok := interface{}(self.identity_error).(gJson.JSONEncodable); ok {
		first = !encoder.EmbedEncodedStruct(je, first) && first
	} else {
		first = !encoder.EmbedMarshaledStruct(self.identity_error, first) && first
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *_shared) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1carno17nf4pt{

		&self.private,
		self.connection,
		self.identity_error,
	})
}

func (self *_shared) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["id"]; ok {
		var temp struct {
			Id string `json:"id,omitempty"`
		}
		data = append(append([]byte("{ \"id\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "id", err.Error(),
			)
		}

		self.private.Id = temp.Id
	}

	if data, ok = m["create_time"]; ok {
		var temp struct {
			CreateTime dateTime `json:"create_time,omitempty"`
		}
		data = append(append([]byte("{ \"create_time\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "create_time", err.Error(),
			)
		}

		self.private.CreateTime = temp.CreateTime
	}

	if data, ok = m["update_time"]; ok {
		var temp struct {
			UpdateTime dateTime `json:"update_time,omitempty"`
		}
		data = append(append([]byte("{ \"update_time\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "update_time", err.Error(),
			)
		}

		self.private.UpdateTime = temp.UpdateTime
	}

	if data, ok = m["state"]; ok {
		var temp struct {
			State StateEnum `json:"state,omitempty"`
		}
		data = append(append([]byte("{ \"state\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "state", err.Error(),
			)
		}

		self.private.State = temp.State
	}

	if data, ok = m["parent_payment"]; ok {
		var temp struct {
			ParentPayment string `json:"parent_payment,omitempty"`
		}
		data = append(append([]byte("{ \"parent_payment\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "parent_payment", err.Error(),
			)
		}

		self.private.ParentPayment = temp.ParentPayment
	}

	if data, ok = m["links"]; ok {
		var temp struct {
			Links links `json:"links,omitempty"`
		}
		data = append(append([]byte("{ \"links\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "links", err.Error(),
			)
		}

		self.private.Links = temp.Links
	}
	return nil
}

/*****************************

amount struct

******************************/

// Amount Object
//  A `Transaction` object also may have an `ItemList`, which has dollar amounts.
//  These amounts are used to calculate the `Total` field of the `Amount` object
//
//	All other uses of `Amount` do have `shipping`, `shipping_discount` and
// `subtotal` to calculate the `Total`.
type amount struct {
	private private_190t0yr7ix7l6
	Details *details `json:"details,omitempty"`
}
type private_190t0yr7ix7l6 struct {
	Currency CurrencyTypeEnum `json:"currency"`
	Total    float64          `json:"total,string"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_190t0yr7ix7l6) JSONEncode(encoder *gJson.Encoder) bool {
	var first = true

	if true {
		var d interface{}

		if true && reflect.ValueOf(self.Currency).Kind() == reflect.Struct {
			d = &self.Currency
		} else {
			d = self.Currency
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("currency", d, first, false) && first
		}
	}

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Total).Kind() == reflect.Struct {
			d = &self.Total
		} else {
			d = self.Total
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("total", d, first, false) && first
		}
	}

	return !first
}

type json_190t0yr7ix7l6 struct {
	*private_190t0yr7ix7l6

	Details *details `json:"details,omitempty"`
}

func (self *amount) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

func (self *amount) Total() float64 {
	return self.private.Total
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *amount) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	var first = !self.private.JSONEncode(encoder)

	if z, ok := interface{}(self.Details).(gJson.Elidable); !ok || !z.CanElide() {
		var d interface{}

		if true && reflect.ValueOf(self.Details).Kind() == reflect.Struct {
			d = &self.Details
		} else {
			d = self.Details
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("details", d, first, true) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *amount) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_190t0yr7ix7l6{

		&self.private,
		self.Details,
	})
}

func (self *amount) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["currency"]; ok {
		var temp struct {
			Currency CurrencyTypeEnum `json:"currency"`
		}
		data = append(append([]byte("{ \"currency\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "currency", err.Error(),
			)
		}

		self.private.Currency = temp.Currency
	}

	if data, ok = m["total"]; ok {
		var temp struct {
			Total float64 `json:"total,string"`
		}
		data = append(append([]byte("{ \"total\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "total", err.Error(),
			)
		}

		self.private.Total = temp.Total
	}

	if data, ok = m["details"]; ok {
		var temp struct {
			Details *details `json:"details,omitempty"`
		}
		data = append(append([]byte("{ \"details\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "details", err.Error(),
			)
		}

		self.Details = temp.Details
	}
	return nil
}

/*****************************

details struct

******************************/

// The Details can all be read/write because the Amount object is read only,
// so it gets a copy anyway.
// No need to validate because its values are calculated or validated when set.
type details struct {
	private private_639q0eflqggf
	// Amount charged for shipping. 10 chars max, with support for 2 decimal places
	Shipping float64 `json:"shipping,string,omitempty"`
	// Amount being charged for handling fee. When `payment_method` is `paypal`
	HandlingFee float64 `json:"handling_fee,string,omitempty"`
	// Amount being charged for insurance fee. When `payment_method` is `paypal`
	Insurance float64 `json:"insurance,string,omitempty"`
	// Amount being discounted for shipping fee. When `payment_method` is `paypal`
	ShippingDiscount float64 `json:"shipping_discount,string,omitempty"`
}
type private_639q0eflqggf struct {
	// Amount of the subtotal of the items. REQUIRED if line items are specified.
	// 10 chars max, with support for 2 decimal places
	Subtotal float64 `json:"subtotal,string,omitempty"`
	// Amount charged for tax. 10 chars max, with support for 2 decimal places
	Tax float64 `json:"tax,string,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_639q0eflqggf) JSONEncode(encoder *gJson.Encoder) bool {
	var first = true

	if self.Subtotal != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Subtotal).Kind() == reflect.Struct {
			d = &self.Subtotal
		} else {
			d = self.Subtotal
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("subtotal", d, first, true) && first
		}
	}

	if self.Tax != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Tax).Kind() == reflect.Struct {
			d = &self.Tax
		} else {
			d = self.Tax
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("tax", d, first, true) && first
		}
	}

	return !first
}

type json_639q0eflqggf struct {
	*private_639q0eflqggf

	Shipping         float64 `json:"shipping,string,omitempty"`
	HandlingFee      float64 `json:"handling_fee,string,omitempty"`
	Insurance        float64 `json:"insurance,string,omitempty"`
	ShippingDiscount float64 `json:"shipping_discount,string,omitempty"`
}

func (self *details) Subtotal() float64 {
	return self.private.Subtotal
}

func (self *details) Tax() float64 {
	return self.private.Tax
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *details) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	var first = !self.private.JSONEncode(encoder)

	if self.Shipping != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Shipping).Kind() == reflect.Struct {
			d = &self.Shipping
		} else {
			d = self.Shipping
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("shipping", d, first, true) && first
		}
	}

	if self.HandlingFee != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.HandlingFee).Kind() == reflect.Struct {
			d = &self.HandlingFee
		} else {
			d = self.HandlingFee
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("handling_fee", d, first, true) && first
		}
	}

	if self.Insurance != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Insurance).Kind() == reflect.Struct {
			d = &self.Insurance
		} else {
			d = self.Insurance
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("insurance", d, first, true) && first
		}
	}

	if self.ShippingDiscount != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.ShippingDiscount).Kind() == reflect.Struct {
			d = &self.ShippingDiscount
		} else {
			d = self.ShippingDiscount
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("shipping_discount", d, first, true) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *details) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_639q0eflqggf{

		&self.private,
		self.Shipping,
		self.HandlingFee,
		self.Insurance,
		self.ShippingDiscount,
	})
}

func (self *details) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["subtotal"]; ok {
		var temp struct {
			Subtotal float64 `json:"subtotal,string,omitempty"`
		}
		data = append(append([]byte("{ \"subtotal\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "subtotal", err.Error(),
			)
		}

		self.private.Subtotal = temp.Subtotal
	}

	if data, ok = m["tax"]; ok {
		var temp struct {
			Tax float64 `json:"tax,string,omitempty"`
		}
		data = append(append([]byte("{ \"tax\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "tax", err.Error(),
			)
		}

		self.private.Tax = temp.Tax
	}

	if data, ok = m["shipping"]; ok {
		var temp struct {
			Shipping float64 `json:"shipping,string,omitempty"`
		}
		data = append(append([]byte("{ \"shipping\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "shipping", err.Error(),
			)
		}

		self.Shipping = temp.Shipping
	}

	if data, ok = m["handling_fee"]; ok {
		var temp struct {
			HandlingFee float64 `json:"handling_fee,string,omitempty"`
		}
		data = append(append([]byte("{ \"handling_fee\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "handling_fee", err.Error(),
			)
		}

		self.HandlingFee = temp.HandlingFee
	}

	if data, ok = m["insurance"]; ok {
		var temp struct {
			Insurance float64 `json:"insurance,string,omitempty"`
		}
		data = append(append([]byte("{ \"insurance\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "insurance", err.Error(),
			)
		}

		self.Insurance = temp.Insurance
	}

	if data, ok = m["shipping_discount"]; ok {
		var temp struct {
			ShippingDiscount float64 `json:"shipping_discount,string,omitempty"`
		}
		data = append(append([]byte("{ \"shipping_discount\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "shipping_discount", err.Error(),
			)
		}

		self.ShippingDiscount = temp.ShippingDiscount
	}
	return nil
}

/*****************************

link struct

******************************/

type link struct {
	private private_1xapfpvhaql57
}
type private_1xapfpvhaql57 struct {
	Href   string      `json:"href,omitempty"`
	Rel    relTypeEnum `json:"rel,omitempty"`
	Method string      `json:"method,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1xapfpvhaql57) JSONEncode(encoder *gJson.Encoder) bool {
	var first = true

	if len(self.Href) != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Href).Kind() == reflect.Struct {
			d = &self.Href
		} else {
			d = self.Href
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("href", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.Rel).(gJson.Elidable); !ok || !z.CanElide() {
		var d interface{}

		if true && reflect.ValueOf(self.Rel).Kind() == reflect.Struct {
			d = &self.Rel
		} else {
			d = self.Rel
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("rel", d, first, true) && first
		}
	}

	if len(self.Method) != 0 {
		var d interface{}

		if false && reflect.ValueOf(self.Method).Kind() == reflect.Struct {
			d = &self.Method
		} else {
			d = self.Method
		}

		var doEncode = true
		if true { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("method", d, first, true) && first
		}
	}

	return !first
}

type json_1xapfpvhaql57 struct {
	*private_1xapfpvhaql57
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *link) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	var first = !self.private.JSONEncode(encoder)

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *link) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1xapfpvhaql57{

		&self.private,
	})
}

func (self *link) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["href"]; ok {
		var temp struct {
			Href string `json:"href,omitempty"`
		}
		data = append(append([]byte("{ \"href\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "href", err.Error(),
			)
		}

		self.private.Href = temp.Href
	}

	if data, ok = m["rel"]; ok {
		var temp struct {
			Rel relTypeEnum `json:"rel,omitempty"`
		}
		data = append(append([]byte("{ \"rel\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "rel", err.Error(),
			)
		}

		self.private.Rel = temp.Rel
	}

	if data, ok = m["method"]; ok {
		var temp struct {
			Method string `json:"method,omitempty"`
		}
		data = append(append([]byte("{ \"method\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "method", err.Error(),
			)
		}

		self.private.Method = temp.Method
	}
	return nil
}

/*****************************

currency struct

******************************/

// Base object for all financial value related fields (balance, payment due, etc.)
type currency struct {
	Currency string `json:"currency"`
	Value    string `json:"value"`
}

type json_1t30d5drxrywn struct {
	Currency string `json:"currency"`
	Value    string `json:"value"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *currency) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')

	var first = true

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Currency).Kind() == reflect.Struct {
			d = &self.Currency
		} else {
			d = self.Currency
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("currency", d, first, false) && first
		}
	}

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Value).Kind() == reflect.Struct {
			d = &self.Value
		} else {
			d = self.Value
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("value", d, first, false) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *currency) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1t30d5drxrywn{
		self.Currency,
		self.Value,
	})
}

func (self *currency) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["currency"]; ok {
		var temp struct {
			Currency string `json:"currency"`
		}
		data = append(append([]byte("{ \"currency\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "currency", err.Error(),
			)
		}

		self.Currency = temp.Currency
	}

	if data, ok = m["value"]; ok {
		var temp struct {
			Value string `json:"value"`
		}
		data = append(append([]byte("{ \"value\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "value", err.Error(),
			)
		}

		self.Value = temp.Value
	}
	return nil
}

/*****************************

fmfDetails struct

******************************/

// This object represents Fraud Management Filter (FMF) details for a payment.
type fmfDetails struct {
	private private_1gf1iytlginvn
}
type private_1gf1iytlginvn struct {
	FilterType  fmfFilterEnum `json:"filter_type"`
	FilterID    filterIdEnum  `json:"filter_id"`
	Name        string        `json:"name"`
	Description string        `json:"description"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1gf1iytlginvn) JSONEncode(encoder *gJson.Encoder) bool {
	var first = true

	if true {
		var d interface{}

		if true && reflect.ValueOf(self.FilterType).Kind() == reflect.Struct {
			d = &self.FilterType
		} else {
			d = self.FilterType
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("filter_type", d, first, false) && first
		}
	}

	if true {
		var d interface{}

		if true && reflect.ValueOf(self.FilterID).Kind() == reflect.Struct {
			d = &self.FilterID
		} else {
			d = self.FilterID
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("filter_id", d, first, false) && first
		}
	}

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Name).Kind() == reflect.Struct {
			d = &self.Name
		} else {
			d = self.Name
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("name", d, first, false) && first
		}
	}

	if true {
		var d interface{}

		if false && reflect.ValueOf(self.Description).Kind() == reflect.Struct {
			d = &self.Description
		} else {
			d = self.Description
		}

		var doEncode = true
		if false { // has omitempty?
			if eli, okCanElide := d.(gJson.Elidable); okCanElide {
				doEncode = !eli.CanElide()

			} else if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("description", d, first, false) && first
		}
	}

	return !first
}

type json_1gf1iytlginvn struct {
	*private_1gf1iytlginvn
}

func (self *fmfDetails) FilterType() fmfFilterEnum {
	return self.private.FilterType
}

func (self *fmfDetails) FilterID() filterIdEnum {
	return self.private.FilterID
}

func (self *fmfDetails) Name() string {
	return self.private.Name
}

func (self *fmfDetails) Description() string {
	return self.private.Description
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *fmfDetails) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	var first = !self.private.JSONEncode(encoder)

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *fmfDetails) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1gf1iytlginvn{

		&self.private,
	})
}

func (self *fmfDetails) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["filter_type"]; ok {
		var temp struct {
			FilterType fmfFilterEnum `json:"filter_type"`
		}
		data = append(append([]byte("{ \"filter_type\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "filter_type", err.Error(),
			)
		}

		self.private.FilterType = temp.FilterType
	}

	if data, ok = m["filter_id"]; ok {
		var temp struct {
			FilterID filterIdEnum `json:"filter_id"`
		}
		data = append(append([]byte("{ \"filter_id\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "filter_id", err.Error(),
			)
		}

		self.private.FilterID = temp.FilterID
	}

	if data, ok = m["name"]; ok {
		var temp struct {
			Name string `json:"name"`
		}
		data = append(append([]byte("{ \"name\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "name", err.Error(),
			)
		}

		self.private.Name = temp.Name
	}

	if data, ok = m["description"]; ok {
		var temp struct {
			Description string `json:"description"`
		}
		data = append(append([]byte("{ \"description\":"), data...), '}')

		if err = json.Unmarshal(data, &temp); err != nil {
			return fmt.Errorf(
				"Field: %s, Error: %s", "description", err.Error(),
			)
		}

		self.private.Description = temp.Description
	}
	return nil
}
