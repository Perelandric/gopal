/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"encoding/json"
)

/*****************************

CreditCardPayment struct

******************************/
func NewCreditCardPayment() *CreditCardPayment {
	return &CreditCardPayment{
		private: private_r7ursfl4o4rf{},
	}
}

// TODO: Add `billing_agreement_tokens`, `payment_instruction`
type CreditCardPayment struct {
	private private_r7ursfl4o4rf
	*connection
	PaymentBase
	ExperienceProfileId string `json:"experience_profile_id"`
	*payment_error
}

type private_r7ursfl4o4rf struct {
	Intent        intentEnum        `json:"intent,omitempty"`
	Payer         creditCardPayer   `json:"payer,omitempty"`
	RedirectUrls  Redirects         `json:"redirect_urls,omitempty"`
	State         stateEnum         `json:"state,omitempty"`
	Id            string            `json:"id,omitempty"`
	FailureReason FailureReasonEnum `json:"failure_reason,omitempty"`
	CreateTime    dateTime          `json:"create_time,omitempty"`
	UpdateTime    dateTime          `json:"update_time,omitempty"`
	Links         links             `json:"links,omitempty"`
}

type json_r7ursfl4o4rf struct {
	*private_r7ursfl4o4rf
	*connection
	PaymentBase
	ExperienceProfileId string `json:"experience_profile_id"`
	*payment_error
}

func (self *CreditCardPayment) Intent() intentEnum {
	return self.private.Intent
}

func (self *CreditCardPayment) Payer() creditCardPayer {
	return self.private.Payer
}

func (self *CreditCardPayment) RedirectUrls() Redirects {
	return self.private.RedirectUrls
}

func (self *CreditCardPayment) State() stateEnum {
	return self.private.State
}

func (self *CreditCardPayment) Id() string {
	return self.private.Id
}

func (self *CreditCardPayment) FailureReason() FailureReasonEnum {
	return self.private.FailureReason
}

func (self *CreditCardPayment) CreateTime() dateTime {
	return self.private.CreateTime
}

func (self *CreditCardPayment) UpdateTime() dateTime {
	return self.private.UpdateTime
}

func (self *CreditCardPayment) Links() links {
	return self.private.Links
}

func (self *CreditCardPayment) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_r7ursfl4o4rf{
		&self.private,
		self.connection,
		self.PaymentBase,
		self.ExperienceProfileId,
		self.payment_error,
	})
}

func (self *CreditCardPayment) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "experience_profile_id":
			err = json.Unmarshal(rawMsg, &self.ExperienceProfileId)
		case "intent":
			err = json.Unmarshal(rawMsg, &self.private.Intent)
		case "payer":
			err = json.Unmarshal(rawMsg, &self.private.Payer)
		case "redirect_urls":
			err = json.Unmarshal(rawMsg, &self.private.RedirectUrls)
		case "state":
			err = json.Unmarshal(rawMsg, &self.private.State)
		case "id":
			err = json.Unmarshal(rawMsg, &self.private.Id)
		case "failure_reason":
			err = json.Unmarshal(rawMsg, &self.private.FailureReason)
		case "create_time":
			err = json.Unmarshal(rawMsg, &self.private.CreateTime)
		case "update_time":
			err = json.Unmarshal(rawMsg, &self.private.UpdateTime)
		case "links":
			err = json.Unmarshal(rawMsg, &self.private.Links)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

creditCardPayer struct

******************************/
func NewCreditCardPayer() *creditCardPayer {
	return &creditCardPayer{
		private: private_1qwarwc5gckfy{},
	}
}

// Source of the funds for this payment represented by a credit card.
type creditCardPayer struct {
	private private_1qwarwc5gckfy
}

type private_1qwarwc5gckfy struct {
	// Must be PaymentMethod.CreditCard
	PaymentMethod      PaymentMethodEnum  `json:"payment_method,omitempty"`
	FundingInstruments fundingInstruments `json:"funding_instruments,omitempty"`
	PayerInfo          *PayerInfo         `json:"payer_info,omitempty"`
}

type json_1qwarwc5gckfy struct {
	*private_1qwarwc5gckfy
}

func (self *creditCardPayer) PaymentMethod() PaymentMethodEnum {
	return self.private.PaymentMethod
}

func (self *creditCardPayer) FundingInstruments() fundingInstruments {
	return self.private.FundingInstruments
}

func (self *creditCardPayer) PayerInfo() *PayerInfo {
	return self.private.PayerInfo
}

func (self *creditCardPayer) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1qwarwc5gckfy{
		&self.private,
	})
}

func (self *creditCardPayer) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "payment_method":
			err = json.Unmarshal(rawMsg, &self.private.PaymentMethod)
		case "funding_instruments":
			err = json.Unmarshal(rawMsg, &self.private.FundingInstruments)
		case "payer_info":
			err = json.Unmarshal(rawMsg, &self.private.PayerInfo)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

PayerInfo struct

******************************/
func NewPayerInfo() *PayerInfo {
	return &PayerInfo{
		private: private_1j704pmy8dq7k{},
	}
}

type PayerInfo struct {
	private private_1j704pmy8dq7k
	// Email address representing the payer. 127 characters max.
	Email string `json:"email,omitempty"`
	// Salutation of the payer.
	Salutation string `json:"salutation,omitempty"`
	// Suffix of the payer.
	Suffix string `json:"suffix,omitempty"`
	// Two-letter registered country code of the payer to identify the buyer country.
	CountryCode CountryCodeEnum `json:"country_code,omitempty"`
	// Phone number representing the payer. 20 characters max.
	Phone string `json:"phone,omitempty"`
	// Payer’s tax ID type. Allowed values: BR_CPF or BR_CNPJ. Only supported when
	// the payment_method is set to paypal.
	TaxIdType TaxIdTypeEnum `json:"tax_id_type,omitempty"`
	// Payer’s tax ID. Only supported when the payment_method is set to paypal.
	TaxId string `json:"tax_id,omitempty"`
}

type private_1j704pmy8dq7k struct {
	// First name of the payer. Value assigned by PayPal.
	FirstName string `json:"first_name,omitempty"`
	// Middle name of the payer. Value assigned by PayPal.
	MiddleName string `json:"middle_name,omitempty"`
	// Last name of the payer. Value assigned by PayPal.
	LastName string `json:"last_name,omitempty"`
	// PayPal assigned Payer ID. Value assigned by PayPal.
	PayerId string `json:"payer_id,omitempty"`
	// Shipping address of payer PayPal account. Value assigned by PayPal.
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

type json_1j704pmy8dq7k struct {
	*private_1j704pmy8dq7k
	Email       string          `json:"email,omitempty"`
	Salutation  string          `json:"salutation,omitempty"`
	Suffix      string          `json:"suffix,omitempty"`
	CountryCode CountryCodeEnum `json:"country_code,omitempty"`
	Phone       string          `json:"phone,omitempty"`
	TaxIdType   TaxIdTypeEnum   `json:"tax_id_type,omitempty"`
	TaxId       string          `json:"tax_id,omitempty"`
}

func (self *PayerInfo) FirstName() string {
	return self.private.FirstName
}

func (self *PayerInfo) MiddleName() string {
	return self.private.MiddleName
}

func (self *PayerInfo) LastName() string {
	return self.private.LastName
}

func (self *PayerInfo) PayerId() string {
	return self.private.PayerId
}

func (self *PayerInfo) ShippingAddress() *ShippingAddress {
	return self.private.ShippingAddress
}

func (self *PayerInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1j704pmy8dq7k{
		&self.private,
		self.Email,
		self.Salutation,
		self.Suffix,
		self.CountryCode,
		self.Phone,
		self.TaxIdType,
		self.TaxId,
	})
}

func (self *PayerInfo) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "email":
			err = json.Unmarshal(rawMsg, &self.Email)
		case "salutation":
			err = json.Unmarshal(rawMsg, &self.Salutation)
		case "suffix":
			err = json.Unmarshal(rawMsg, &self.Suffix)
		case "country_code":
			err = json.Unmarshal(rawMsg, &self.CountryCode)
		case "phone":
			err = json.Unmarshal(rawMsg, &self.Phone)
		case "tax_id_type":
			err = json.Unmarshal(rawMsg, &self.TaxIdType)
		case "tax_id":
			err = json.Unmarshal(rawMsg, &self.TaxId)
		case "first_name":
			err = json.Unmarshal(rawMsg, &self.private.FirstName)
		case "middle_name":
			err = json.Unmarshal(rawMsg, &self.private.MiddleName)
		case "last_name":
			err = json.Unmarshal(rawMsg, &self.private.LastName)
		case "payer_id":
			err = json.Unmarshal(rawMsg, &self.private.PayerId)
		case "shipping_address":
			err = json.Unmarshal(rawMsg, &self.private.ShippingAddress)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}
