/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"encoding/json"
)

/*****************************

CreditCardPayment struct

******************************/
func NewCreditCardPayment() *CreditCardPayment {
	return &CreditCardPayment{
		private: private_hpacftjaj7ke{},
	}
}

// TODO: Add `billing_agreement_tokens`, `payment_instruction`
type CreditCardPayment struct {
	private private_hpacftjaj7ke
	*connection
	ExperienceProfileId string `json:"experience_profile_id"`
	*payment_error
}

type private_hpacftjaj7ke struct {
	Intent        intentEnum             `json:"intent,omitempty"`
	State         StateEnum              `json:"state,omitempty"`
	Id            string                 `json:"id,omitempty"`
	FailureReason FailureReasonEnum      `json:"failure_reason,omitempty"`
	CreateTime    dateTime               `json:"create_time,omitempty"`
	UpdateTime    dateTime               `json:"update_time,omitempty"`
	Links         links                  `json:"links,omitempty"`
	Transactions  CreditCardTransactions `json:"transactions,omitempty"`
	Payer         creditCardPayer        `json:"payer,omitempty"`
	RedirectUrls  Redirects              `json:"redirect_urls,omitempty"`
}

type json_hpacftjaj7ke struct {
	*private_hpacftjaj7ke
	*connection
	ExperienceProfileId string `json:"experience_profile_id"`
	*payment_error
}

func (self *CreditCardPayment) Intent() intentEnum {
	return self.private.Intent
}

func (self *CreditCardPayment) State() StateEnum {
	return self.private.State
}

func (self *CreditCardPayment) Id() string {
	return self.private.Id
}

func (self *CreditCardPayment) FailureReason() FailureReasonEnum {
	return self.private.FailureReason
}

func (self *CreditCardPayment) CreateTime() dateTime {
	return self.private.CreateTime
}

func (self *CreditCardPayment) UpdateTime() dateTime {
	return self.private.UpdateTime
}

func (self *CreditCardPayment) Links() links {
	return self.private.Links
}

func (self *CreditCardPayment) Transactions() CreditCardTransactions {
	return self.private.Transactions
}

func (self *CreditCardPayment) Payer() creditCardPayer {
	return self.private.Payer
}

func (self *CreditCardPayment) RedirectUrls() Redirects {
	return self.private.RedirectUrls
}

func (self *CreditCardPayment) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_hpacftjaj7ke{
		&self.private,
		self.connection,
		self.ExperienceProfileId,
		self.payment_error,
	})
}

func (self *CreditCardPayment) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		// The anon structs in each case are needed for field tags

		switch key {
		case "intent":

			var x struct {
				F intentEnum `json:"intent,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.Intent = x.F
		case "state":

			var x struct {
				F StateEnum `json:"state,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.State = x.F
		case "id":

			var x struct {
				F string `json:"id,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.Id = x.F
		case "failure_reason":

			var x struct {
				F FailureReasonEnum `json:"failure_reason,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.FailureReason = x.F
		case "create_time":

			var x struct {
				F dateTime `json:"create_time,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.CreateTime = x.F
		case "update_time":

			var x struct {
				F dateTime `json:"update_time,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.UpdateTime = x.F
		case "links":

			var x struct {
				F links `json:"links,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.Links = x.F
		case "transactions":

			var x struct {
				F CreditCardTransactions `json:"transactions,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.Transactions = x.F
		case "experience_profile_id":

			var x struct {
				F string `json:"experience_profile_id"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.ExperienceProfileId = x.F

		case "payer":

			var x struct {
				F creditCardPayer `json:"payer,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.Payer = x.F
		case "redirect_urls":

			var x struct {
				F Redirects `json:"redirect_urls,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.RedirectUrls = x.F
		default:
			// Ignoring unknown property
		}
	}
	return nil
}

/*****************************

CreditCardTransaction struct

******************************/
func NewCreditCardTransaction() *CreditCardTransaction {
	return &CreditCardTransaction{
		private: private_1itxeta3zwkii{},
	}
}

type CreditCardTransaction struct {
	private        private_1itxeta3zwkii
	Description    string         `json:"description,omitempty"`
	PaymentOptions paymentOptions `json:"payment_options,omitempty"`
	InvoiceNumber  string         `json:"invoice_number,omitempty"`
	Custom         string         `json:"custom,omitempty"`
	SoftDescriptor string         `json:"soft_descriptor,omitempty"`
}

type private_1itxeta3zwkii struct {
	ItemList         *creditCardItemList `json:"item_list,omitempty"`
	Amount           amount              `json:"amount"`
	RelatedResources relatedResources    `json:"related_resources,omitempty"`
}

type json_1itxeta3zwkii struct {
	*private_1itxeta3zwkii
	Description    string         `json:"description,omitempty"`
	PaymentOptions paymentOptions `json:"payment_options,omitempty"`
	InvoiceNumber  string         `json:"invoice_number,omitempty"`
	Custom         string         `json:"custom,omitempty"`
	SoftDescriptor string         `json:"soft_descriptor,omitempty"`
}

func (self *CreditCardTransaction) ItemList() *creditCardItemList {
	return self.private.ItemList
}

func (self *CreditCardTransaction) Amount() amount {
	return self.private.Amount
}

func (self *CreditCardTransaction) RelatedResources() relatedResources {
	return self.private.RelatedResources
}

func (self *CreditCardTransaction) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1itxeta3zwkii{
		&self.private,
		self.Description,
		self.PaymentOptions,
		self.InvoiceNumber,
		self.Custom,
		self.SoftDescriptor,
	})
}

func (self *CreditCardTransaction) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		// The anon structs in each case are needed for field tags

		switch key {
		case "item_list":

			var x struct {
				F *creditCardItemList `json:"item_list,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.ItemList = x.F
		case "amount":

			var x struct {
				F amount `json:"amount"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.Amount = x.F
		case "related_resources":

			var x struct {
				F relatedResources `json:"related_resources,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.RelatedResources = x.F
		case "description":

			var x struct {
				F string `json:"description,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Description = x.F

		case "payment_options":

			var x struct {
				F paymentOptions `json:"payment_options,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.PaymentOptions = x.F

		case "invoice_number":

			var x struct {
				F string `json:"invoice_number,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.InvoiceNumber = x.F

		case "custom":

			var x struct {
				F string `json:"custom,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Custom = x.F

		case "soft_descriptor":

			var x struct {
				F string `json:"soft_descriptor,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.SoftDescriptor = x.F

		default:
			// Ignoring unknown property
		}
	}
	return nil
}

/*****************************

creditCardItemList struct

******************************/
func NewCreditCardItemList() *creditCardItemList {
	return &creditCardItemList{
		private: private_239zv858iyfm{},
	}
}

type creditCardItemList struct {
	private private_239zv858iyfm
}

type private_239zv858iyfm struct {
	Items           CreditCardItems  `json:"items,omitempty"`
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

type json_239zv858iyfm struct {
	*private_239zv858iyfm
}

func (self *creditCardItemList) Items() CreditCardItems {
	return self.private.Items
}

func (self *creditCardItemList) ShippingAddress() *ShippingAddress {
	return self.private.ShippingAddress
}

func (self *creditCardItemList) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_239zv858iyfm{
		&self.private,
	})
}

func (self *creditCardItemList) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		// The anon structs in each case are needed for field tags

		switch key {
		case "items":

			var x struct {
				F CreditCardItems `json:"items,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.Items = x.F
		case "shipping_address":

			var x struct {
				F *ShippingAddress `json:"shipping_address,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.ShippingAddress = x.F
		default:
			// Ignoring unknown property
		}
	}
	return nil
}

/*****************************

CreditCardItem struct

******************************/
func NewCreditCardItem() *CreditCardItem {
	return &CreditCardItem{
		private: private_1bv69rn2pgw1t{},
	}
}

type CreditCardItem struct {
	private  private_1bv69rn2pgw1t
	Quantity int64   `json:"quantity,string"`
	Name     string  `json:"name"`
	Price    float64 `json:"price,string"`
	Sku      string  `json:"sku,omitempty"`
}

type private_1bv69rn2pgw1t struct {
	Currency CurrencyTypeEnum `json:"currency"`
}

type json_1bv69rn2pgw1t struct {
	*private_1bv69rn2pgw1t
	Quantity int64   `json:"quantity,string"`
	Name     string  `json:"name"`
	Price    float64 `json:"price,string"`
	Sku      string  `json:"sku,omitempty"`
}

func (self *CreditCardItem) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

func (self *CreditCardItem) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1bv69rn2pgw1t{
		&self.private,
		self.Quantity,
		self.Name,
		self.Price,
		self.Sku,
	})
}

func (self *CreditCardItem) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		// The anon structs in each case are needed for field tags

		switch key {
		case "currency":

			var x struct {
				F CurrencyTypeEnum `json:"currency"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.Currency = x.F
		case "quantity":

			var x struct {
				F int64 `json:"quantity,string"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Quantity = x.F

		case "name":

			var x struct {
				F string `json:"name"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Name = x.F

		case "price":

			var x struct {
				F float64 `json:"price,string"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Price = x.F

		case "sku":

			var x struct {
				F string `json:"sku,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Sku = x.F

		default:
			// Ignoring unknown property
		}
	}
	return nil
}

/*****************************

creditCardPayer struct

******************************/
func NewCreditCardPayer() *creditCardPayer {
	return &creditCardPayer{
		private: private_1ekaoszmzm9y8{},
	}
}

// Source of the funds for this payment represented by a credit card.
type creditCardPayer struct {
	private private_1ekaoszmzm9y8
}

type private_1ekaoszmzm9y8 struct {
	// Must be PaymentMethod.CreditCard
	PaymentMethod      PaymentMethodEnum  `json:"payment_method,omitempty"`
	FundingInstruments fundingInstruments `json:"funding_instruments,omitempty"`
	PayerInfo          *PayerInfo         `json:"payer_info,omitempty"`
}

type json_1ekaoszmzm9y8 struct {
	*private_1ekaoszmzm9y8
}

func (self *creditCardPayer) PaymentMethod() PaymentMethodEnum {
	return self.private.PaymentMethod
}

func (self *creditCardPayer) FundingInstruments() fundingInstruments {
	return self.private.FundingInstruments
}

func (self *creditCardPayer) PayerInfo() *PayerInfo {
	return self.private.PayerInfo
}

func (self *creditCardPayer) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1ekaoszmzm9y8{
		&self.private,
	})
}

func (self *creditCardPayer) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		// The anon structs in each case are needed for field tags

		switch key {
		case "payment_method":

			var x struct {
				F PaymentMethodEnum `json:"payment_method,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.PaymentMethod = x.F
		case "funding_instruments":

			var x struct {
				F fundingInstruments `json:"funding_instruments,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.FundingInstruments = x.F
		case "payer_info":

			var x struct {
				F *PayerInfo `json:"payer_info,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.private.PayerInfo = x.F
		default:
			// Ignoring unknown property
		}
	}
	return nil
}

/*****************************

PayerInfo struct

******************************/
func NewPayerInfo() *PayerInfo {
	return &PayerInfo{
		private: private_15gc60v9god0s{},
	}
}

type PayerInfo struct {
	private private_15gc60v9god0s
	// Email address representing the payer. 127 characters max.
	Email string `json:"email,omitempty"`
	// Salutation of the payer.
	Salutation string `json:"salutation,omitempty"`
	// Suffix of the payer.
	Suffix string `json:"suffix,omitempty"`
	// Two-letter registered country code of the payer to identify the buyer country.
	CountryCode CountryCodeEnum `json:"country_code,omitempty"`
	// Phone number representing the payer. 20 characters max.
	Phone string `json:"phone,omitempty"`
	// First name of the payer. Value assigned by PayPal.
	FirstName string `json:"first_name,omitempty"`
	// Middle name of the payer. Value assigned by PayPal.
	MiddleName string `json:"middle_name,omitempty"`
	// Last name of the payer. Value assigned by PayPal.
	LastName string `json:"last_name,omitempty"`
	// PayPal assigned Payer ID. Value assigned by PayPal.
	PayerId string `json:"payer_id,omitempty"`
	// Shipping address of payer PayPal account. Value assigned by PayPal.
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

type private_15gc60v9god0s struct{}

type json_15gc60v9god0s struct {
	*private_15gc60v9god0s
	Email           string           `json:"email,omitempty"`
	Salutation      string           `json:"salutation,omitempty"`
	Suffix          string           `json:"suffix,omitempty"`
	CountryCode     CountryCodeEnum  `json:"country_code,omitempty"`
	Phone           string           `json:"phone,omitempty"`
	FirstName       string           `json:"first_name,omitempty"`
	MiddleName      string           `json:"middle_name,omitempty"`
	LastName        string           `json:"last_name,omitempty"`
	PayerId         string           `json:"payer_id,omitempty"`
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

func (self *PayerInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_15gc60v9god0s{
		&self.private,
		self.Email,
		self.Salutation,
		self.Suffix,
		self.CountryCode,
		self.Phone,
		self.FirstName,
		self.MiddleName,
		self.LastName,
		self.PayerId,
		self.ShippingAddress,
	})
}

func (self *PayerInfo) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		// The anon structs in each case are needed for field tags

		switch key {
		case "email":

			var x struct {
				F string `json:"email,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Email = x.F

		case "salutation":

			var x struct {
				F string `json:"salutation,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Salutation = x.F

		case "suffix":

			var x struct {
				F string `json:"suffix,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Suffix = x.F

		case "country_code":

			var x struct {
				F CountryCodeEnum `json:"country_code,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.CountryCode = x.F

		case "phone":

			var x struct {
				F string `json:"phone,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.Phone = x.F

		case "first_name":

			var x struct {
				F string `json:"first_name,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.FirstName = x.F

		case "middle_name":

			var x struct {
				F string `json:"middle_name,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.MiddleName = x.F

		case "last_name":

			var x struct {
				F string `json:"last_name,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.LastName = x.F

		case "payer_id":

			var x struct {
				F string `json:"payer_id,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.PayerId = x.F

		case "shipping_address":

			var x struct {
				F *ShippingAddress `json:"shipping_address,omitempty"`
			}

			var msgForStruct = append(append(append(append(
				[]byte("{\""), key...), "\":"...), rawMsg...), '}')

			if err = json.Unmarshal(msgForStruct, &x); err != nil {
				return err
			}

			self.ShippingAddress = x.F

		default:
			// Ignoring unknown property
		}
	}
	return nil
}
