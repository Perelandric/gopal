/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"Golific/gJson"
	"encoding/json"
	"strings"
)

/*****************************

Authorization struct

******************************/

// State items are:
// pending, authorized, captured, partially_captured, expired, voided
type Authorization struct {
	private private_ijox678hfw6u
	_shared
}

type private_ijox678hfw6u struct {
	Amount             amount                 `json:"amount"`
	BillingAgreementId string                 `json:"billing_agreement_id"`
	PaymentMode        paymentModeEnum        `json:"payment_mode"`
	ReasonCode         reasonCodeEnum         `json:"reason_code"`
	ValidUntil         dateTime               `json:"valid_until"`
	ClearingTime       string                 `json:"clearing_time"`
	ProtectionElig     protectionEligEnum     `json:"protection_eligibility"`
	ProtectionEligType protectionEligTypeEnum `json:"protection_eligibility_type"`
	FmfDetails         fmfDetails             `json:"fmf_details"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_ijox678hfw6u) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("amount", self.Amount, first)
	first = false

	encoder.EncodeKeyVal("billing_agreement_id", self.BillingAgreementId, first)
	first = false

	encoder.EncodeKeyVal("payment_mode", self.PaymentMode, first)
	first = false

	encoder.EncodeKeyVal("reason_code", self.ReasonCode, first)
	first = false

	encoder.EncodeKeyVal("valid_until", self.ValidUntil, first)
	first = false

	encoder.EncodeKeyVal("clearing_time", self.ClearingTime, first)
	first = false

	encoder.EncodeKeyVal("protection_eligibility", self.ProtectionElig, first)
	first = false

	encoder.EncodeKeyVal("protection_eligibility_type", self.ProtectionEligType, first)
	first = false

	encoder.EncodeKeyVal("fmf_details", self.FmfDetails, first)
	first = false
}

type json_ijox678hfw6u struct {
	*private_ijox678hfw6u
	_shared
}

func (self *Authorization) Amount() amount {
	return self.private.Amount
}

func (self *Authorization) BillingAgreementId() string {
	return self.private.BillingAgreementId
}

func (self *Authorization) PaymentMode() paymentModeEnum {
	return self.private.PaymentMode
}

func (self *Authorization) ReasonCode() reasonCodeEnum {
	return self.private.ReasonCode
}

func (self *Authorization) ValidUntil() dateTime {
	return self.private.ValidUntil
}

func (self *Authorization) ClearingTime() string {
	return self.private.ClearingTime
}

func (self *Authorization) ProtectionElig() protectionEligEnum {
	return self.private.ProtectionElig
}

func (self *Authorization) ProtectionEligType() protectionEligTypeEnum {
	return self.private.ProtectionEligType
}

func (self *Authorization) FmfDetails() fmfDetails {
	return self.private.FmfDetails
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *Authorization) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	if je, ok := interface{}(self._shared).(gJson.JSONEncodable); ok {
		first = encoder.EmbedEncodedStruct(je, first)
	} else {
		first = encoder.EmbedMarshaledStruct(self._shared, first)
	}

	encoder.WriteRawByte('}')
}

func (self *Authorization) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_ijox678hfw6u{
		&self.private,
		self._shared,
	})
}

func (self *Authorization) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["amount"]; ok {
		if err = json.Unmarshal(data, &self.private.Amount); err != nil {
			return err
		}
	}

	if data, ok = m["billing_agreement_id"]; ok {
		if err = json.Unmarshal(data, &self.private.BillingAgreementId); err != nil {
			return err
		}
	}

	if data, ok = m["payment_mode"]; ok {
		if err = json.Unmarshal(data, &self.private.PaymentMode); err != nil {
			return err
		}
	}

	if data, ok = m["reason_code"]; ok {
		if err = json.Unmarshal(data, &self.private.ReasonCode); err != nil {
			return err
		}
	}

	if data, ok = m["valid_until"]; ok {
		if err = json.Unmarshal(data, &self.private.ValidUntil); err != nil {
			return err
		}
	}

	if data, ok = m["clearing_time"]; ok {
		if err = json.Unmarshal(data, &self.private.ClearingTime); err != nil {
			return err
		}
	}

	if data, ok = m["protection_eligibility"]; ok {
		if err = json.Unmarshal(data, &self.private.ProtectionElig); err != nil {
			return err
		}
	}

	if data, ok = m["protection_eligibility_type"]; ok {
		if err = json.Unmarshal(data, &self.private.ProtectionEligType); err != nil {
			return err
		}
	}

	if data, ok = m["fmf_details"]; ok {
		if err = json.Unmarshal(data, &self.private.FmfDetails); err != nil {
			return err
		}
	}
	return nil
}
