/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"Golific/gJson"
	"encoding/json"
	"reflect"
)

/*****************************

Authorization struct

******************************/

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *Authorization) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')
	var first = true

	if je, ok := interface{}(self._shared).(gJson.JSONEncodable); ok {
		first = !encoder.EmbedEncodedStruct(je, first) && first
	} else {
		first = !encoder.EmbedMarshaledStruct(self._shared, first) && first
	}

	if true {
		var d interface{} = self.Amount

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.Amount).Kind() == reflect.Struct {
				d = &self.Amount
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("amount", d, first, false) && first
		}
	}

	if true {
		var d interface{} = self.BillingAgreementId

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.BillingAgreementId).Kind() == reflect.Struct {
				d = &self.BillingAgreementId
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("billing_agreement_id", d, first, false) && first
		}
	}

	if true {
		var d interface{} = self.PaymentMode

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.PaymentMode).Kind() == reflect.Struct {
				d = &self.PaymentMode
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("payment_mode", d, first, false) && first
		}
	}

	if true {
		var d interface{} = self.ReasonCode

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.ReasonCode).Kind() == reflect.Struct {
				d = &self.ReasonCode
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("reason_code", d, first, false) && first
		}
	}

	if true {
		var d interface{} = self.ValidUntil

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.ValidUntil).Kind() == reflect.Struct {
				d = &self.ValidUntil
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("valid_until", d, first, false) && first
		}
	}

	if true {
		var d interface{} = self.ClearingTime

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.ClearingTime).Kind() == reflect.Struct {
				d = &self.ClearingTime
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("clearing_time", d, first, false) && first
		}
	}

	if true {
		var d interface{} = self.ProtectionElig

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.ProtectionElig).Kind() == reflect.Struct {
				d = &self.ProtectionElig
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("protection_eligibility", d, first, false) && first
		}
	}

	if true {
		var d interface{} = self.ProtectionEligType

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.ProtectionEligType).Kind() == reflect.Struct {
				d = &self.ProtectionEligType
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("protection_eligibility_type", d, first, false) && first
		}
	}

	if true {
		var d interface{} = self.FmfDetails

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.FmfDetails).Kind() == reflect.Struct {
				d = &self.FmfDetails
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("fmf_details", d, first, false) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *Authorization) MarshalJSON() ([]byte, error) {
	var encoder gJson.Encoder
	self.JSONEncode(&encoder)
	return encoder.Bytes(), nil
}

func (self *Authorization) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// First unmarshal using the default unmarshaler. The temp type is so that
	// this method is not called recursively.
	type temp *Authorization
	if err := json.Unmarshal(j, temp(self)); err != nil {
		return err
	}

	return nil
}
