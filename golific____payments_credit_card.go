/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"Golific/gJson"
	"encoding/json"
	"strings"
)

/*****************************

CreditCardPayment struct

******************************/

type CreditCardPayment struct {
	private private_131pmv9xj7seu
	*connection
	ExperienceProfileId string `json:"experience_profile_id"`
	*payment_error
}

type private_131pmv9xj7seu struct {
	Intent        intentEnum             `json:"intent,omitempty"`
	State         StateEnum              `json:"state,omitempty"`
	Id            string                 `json:"id,omitempty"`
	FailureReason FailureReasonEnum      `json:"failure_reason,omitempty"`
	CreateTime    dateTime               `json:"create_time,omitempty"`
	UpdateTime    dateTime               `json:"update_time,omitempty"`
	Links         links                  `json:"links,omitempty"`
	Transactions  CreditCardTransactions `json:"transactions,omitempty"`
	Payer         creditCardPayer        `json:"payer,omitempty"`
	RedirectUrls  Redirects              `json:"redirect_urls,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_131pmv9xj7seu) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("intent", self.Intent, first)
	first = false

	encoder.EncodeKeyVal("state", self.State, first)
	first = false

	if len(self.Id) != 0 {
		encoder.EncodeKeyVal("id", self.Id, first)
		first = false
	}

	encoder.EncodeKeyVal("failure_reason", self.FailureReason, first)
	first = false

	encoder.EncodeKeyVal("create_time", self.CreateTime, first)
	first = false

	encoder.EncodeKeyVal("update_time", self.UpdateTime, first)
	first = false

	encoder.EncodeKeyVal("links", self.Links, first)
	first = false

	encoder.EncodeKeyVal("transactions", self.Transactions, first)
	first = false

	encoder.EncodeKeyVal("payer", self.Payer, first)
	first = false

	encoder.EncodeKeyVal("redirect_urls", self.RedirectUrls, first)
	first = false
}

type json_131pmv9xj7seu struct {
	*private_131pmv9xj7seu
	*connection
	ExperienceProfileId string `json:"experience_profile_id"`
	*payment_error
}

func (self *CreditCardPayment) Intent() intentEnum {
	return self.private.Intent
}

func (self *CreditCardPayment) State() StateEnum {
	return self.private.State
}

func (self *CreditCardPayment) Id() string {
	return self.private.Id
}

func (self *CreditCardPayment) FailureReason() FailureReasonEnum {
	return self.private.FailureReason
}

func (self *CreditCardPayment) CreateTime() dateTime {
	return self.private.CreateTime
}

func (self *CreditCardPayment) UpdateTime() dateTime {
	return self.private.UpdateTime
}

func (self *CreditCardPayment) Links() links {
	return self.private.Links
}

func (self *CreditCardPayment) Transactions() CreditCardTransactions {
	return self.private.Transactions
}

func (self *CreditCardPayment) Payer() creditCardPayer {
	return self.private.Payer
}

func (self *CreditCardPayment) RedirectUrls() Redirects {
	return self.private.RedirectUrls
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *CreditCardPayment) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	if je, ok := interface{}(self.connection).(gJson.JSONEncodable); ok {
		first = encoder.EmbedEncodedStruct(je, first)
	} else {
		first = encoder.EmbedMarshaledStruct(self.connection, first)
	}

	encoder.EncodeKeyVal("experience_profile_id", self.ExperienceProfileId, first)
	first = false

	if je, ok := interface{}(self.payment_error).(gJson.JSONEncodable); ok {
		first = encoder.EmbedEncodedStruct(je, first)
	} else {
		first = encoder.EmbedMarshaledStruct(self.payment_error, first)
	}

	encoder.WriteRawByte('}')
}

func (self *CreditCardPayment) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_131pmv9xj7seu{
		&self.private,
		self.connection,
		self.ExperienceProfileId,
		self.payment_error,
	})
}

func (self *CreditCardPayment) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["intent"]; ok {
		if err = json.Unmarshal(data, &self.private.Intent); err != nil {
			return err
		}
	}

	if data, ok = m["state"]; ok {
		if err = json.Unmarshal(data, &self.private.State); err != nil {
			return err
		}
	}

	if data, ok = m["id"]; ok {
		if err = json.Unmarshal(data, &self.private.Id); err != nil {
			return err
		}
	}

	if data, ok = m["failure_reason"]; ok {
		if err = json.Unmarshal(data, &self.private.FailureReason); err != nil {
			return err
		}
	}

	if data, ok = m["create_time"]; ok {
		if err = json.Unmarshal(data, &self.private.CreateTime); err != nil {
			return err
		}
	}

	if data, ok = m["update_time"]; ok {
		if err = json.Unmarshal(data, &self.private.UpdateTime); err != nil {
			return err
		}
	}

	if data, ok = m["links"]; ok {
		if err = json.Unmarshal(data, &self.private.Links); err != nil {
			return err
		}
	}

	if data, ok = m["transactions"]; ok {
		if err = json.Unmarshal(data, &self.private.Transactions); err != nil {
			return err
		}
	}

	if data, ok = m["experience_profile_id"]; ok {
		if err = json.Unmarshal(data, &self.ExperienceProfileId); err != nil {
			return err
		}
	}

	if data, ok = m["payer"]; ok {
		if err = json.Unmarshal(data, &self.private.Payer); err != nil {
			return err
		}
	}

	if data, ok = m["redirect_urls"]; ok {
		if err = json.Unmarshal(data, &self.private.RedirectUrls); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

CreditCardTransaction struct

******************************/

type CreditCardTransaction struct {
	private        private_mnmksc378c5m
	Description    string         `json:"description,omitempty"`
	PaymentOptions paymentOptions `json:"payment_options,omitempty"`
	InvoiceNumber  string         `json:"invoice_number,omitempty"`
	Custom         string         `json:"custom,omitempty"`
	SoftDescriptor string         `json:"soft_descriptor,omitempty"`
}

type private_mnmksc378c5m struct {
	ItemList         *creditCardItemList `json:"item_list,omitempty"`
	Amount           amount              `json:"amount"`
	RelatedResources relatedResources    `json:"related_resources,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_mnmksc378c5m) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	if z, ok := interface{}(self.ItemList).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("item_list", self.ItemList, first)
		first = false
	}

	encoder.EncodeKeyVal("amount", self.Amount, first)
	first = false

	encoder.EncodeKeyVal("related_resources", self.RelatedResources, first)
	first = false
}

type json_mnmksc378c5m struct {
	*private_mnmksc378c5m
	Description    string         `json:"description,omitempty"`
	PaymentOptions paymentOptions `json:"payment_options,omitempty"`
	InvoiceNumber  string         `json:"invoice_number,omitempty"`
	Custom         string         `json:"custom,omitempty"`
	SoftDescriptor string         `json:"soft_descriptor,omitempty"`
}

func (self *CreditCardTransaction) ItemList() *creditCardItemList {
	return self.private.ItemList
}

func (self *CreditCardTransaction) Amount() amount {
	return self.private.Amount
}

func (self *CreditCardTransaction) RelatedResources() relatedResources {
	return self.private.RelatedResources
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *CreditCardTransaction) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	if len(self.Description) != 0 {
		encoder.EncodeKeyVal("description", self.Description, first)
		first = false
	}

	encoder.EncodeKeyVal("payment_options", self.PaymentOptions, first)
	first = false

	if len(self.InvoiceNumber) != 0 {
		encoder.EncodeKeyVal("invoice_number", self.InvoiceNumber, first)
		first = false
	}

	if len(self.Custom) != 0 {
		encoder.EncodeKeyVal("custom", self.Custom, first)
		first = false
	}

	if len(self.SoftDescriptor) != 0 {
		encoder.EncodeKeyVal("soft_descriptor", self.SoftDescriptor, first)
		first = false
	}
	encoder.WriteRawByte('}')
}

func (self *CreditCardTransaction) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_mnmksc378c5m{
		&self.private,
		self.Description,
		self.PaymentOptions,
		self.InvoiceNumber,
		self.Custom,
		self.SoftDescriptor,
	})
}

func (self *CreditCardTransaction) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["item_list"]; ok {
		if err = json.Unmarshal(data, &self.private.ItemList); err != nil {
			return err
		}
	}

	if data, ok = m["amount"]; ok {
		if err = json.Unmarshal(data, &self.private.Amount); err != nil {
			return err
		}
	}

	if data, ok = m["related_resources"]; ok {
		if err = json.Unmarshal(data, &self.private.RelatedResources); err != nil {
			return err
		}
	}

	if data, ok = m["description"]; ok {
		if err = json.Unmarshal(data, &self.Description); err != nil {
			return err
		}
	}

	if data, ok = m["payment_options"]; ok {
		if err = json.Unmarshal(data, &self.PaymentOptions); err != nil {
			return err
		}
	}

	if data, ok = m["invoice_number"]; ok {
		if err = json.Unmarshal(data, &self.InvoiceNumber); err != nil {
			return err
		}
	}

	if data, ok = m["custom"]; ok {
		if err = json.Unmarshal(data, &self.Custom); err != nil {
			return err
		}
	}

	if data, ok = m["soft_descriptor"]; ok {
		if err = json.Unmarshal(data, &self.SoftDescriptor); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

creditCardItemList struct

******************************/

type creditCardItemList struct {
	private private_1fj8bwtmbsjho
}

type private_1fj8bwtmbsjho struct {
	Items           []*CreditCardItem `json:"items,omitempty"`
	ShippingAddress *ShippingAddress  `json:"shipping_address,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1fj8bwtmbsjho) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	if len(self.Items) != 0 {
		encoder.EncodeKeyVal("items", self.Items, first)
		first = false
	}

	if z, ok := interface{}(self.ShippingAddress).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("shipping_address", self.ShippingAddress, first)
		first = false
	}
}

type json_1fj8bwtmbsjho struct {
	*private_1fj8bwtmbsjho
}

func (self *creditCardItemList) Items() []*CreditCardItem {
	return self.private.Items
}

func (self *creditCardItemList) ShippingAddress() *ShippingAddress {
	return self.private.ShippingAddress
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *creditCardItemList) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	encoder.WriteRawByte('}')
}

func (self *creditCardItemList) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1fj8bwtmbsjho{
		&self.private,
	})
}

func (self *creditCardItemList) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["items"]; ok {
		if err = json.Unmarshal(data, &self.private.Items); err != nil {
			return err
		}
	}

	if data, ok = m["shipping_address"]; ok {
		if err = json.Unmarshal(data, &self.private.ShippingAddress); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

creditCardPayer struct

******************************/

// Source of the funds for this payment represented by a credit card.
type creditCardPayer struct {
	private private_1iata3hypddtl
}

type private_1iata3hypddtl struct {
	// Must be PaymentMethod.CreditCard
	PaymentMethod      PaymentMethodEnum  `json:"payment_method,omitempty"`
	FundingInstruments fundingInstruments `json:"funding_instruments,omitempty"`
	PayerInfo          *PayerInfo         `json:"payer_info,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1iata3hypddtl) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("payment_method", self.PaymentMethod, first)
	first = false

	encoder.EncodeKeyVal("funding_instruments", self.FundingInstruments, first)
	first = false

	if z, ok := interface{}(self.PayerInfo).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("payer_info", self.PayerInfo, first)
		first = false
	}
}

type json_1iata3hypddtl struct {
	*private_1iata3hypddtl
}

func (self *creditCardPayer) PaymentMethod() PaymentMethodEnum {
	return self.private.PaymentMethod
}

func (self *creditCardPayer) FundingInstruments() fundingInstruments {
	return self.private.FundingInstruments
}

func (self *creditCardPayer) PayerInfo() *PayerInfo {
	return self.private.PayerInfo
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *creditCardPayer) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	encoder.WriteRawByte('}')
}

func (self *creditCardPayer) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1iata3hypddtl{
		&self.private,
	})
}

func (self *creditCardPayer) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["payment_method"]; ok {
		if err = json.Unmarshal(data, &self.private.PaymentMethod); err != nil {
			return err
		}
	}

	if data, ok = m["funding_instruments"]; ok {
		if err = json.Unmarshal(data, &self.private.FundingInstruments); err != nil {
			return err
		}
	}

	if data, ok = m["payer_info"]; ok {
		if err = json.Unmarshal(data, &self.private.PayerInfo); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

PayerInfo struct

******************************/

type PayerInfo struct {
	private private_6m1cp3rqht78
	// Email address representing the payer. 127 characters max.
	Email string `json:"email,omitempty"`
	// Salutation of the payer.
	Salutation string `json:"salutation,omitempty"`
	// Suffix of the payer.
	Suffix string `json:"suffix,omitempty"`
	// Two-letter registered country code of the payer to identify the buyer country.
	CountryCode CountryCodeEnum `json:"country_code,omitempty"`
	// Phone number representing the payer. 20 characters max.
	Phone string `json:"phone,omitempty"`
	// First name of the payer. Value assigned by PayPal.
	FirstName string `json:"first_name,omitempty"`
	// Middle name of the payer. Value assigned by PayPal.
	MiddleName string `json:"middle_name,omitempty"`
	// Last name of the payer. Value assigned by PayPal.
	LastName string `json:"last_name,omitempty"`
	// PayPal assigned Payer ID. Value assigned by PayPal.
	PayerId string `json:"payer_id,omitempty"`
	// Shipping address of payer PayPal account. Value assigned by PayPal.
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

type private_6m1cp3rqht78 struct{}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_6m1cp3rqht78) JSONEncode(encoder *gJson.Encoder) {}

type json_6m1cp3rqht78 struct {
	*private_6m1cp3rqht78
	Email           string           `json:"email,omitempty"`
	Salutation      string           `json:"salutation,omitempty"`
	Suffix          string           `json:"suffix,omitempty"`
	CountryCode     CountryCodeEnum  `json:"country_code,omitempty"`
	Phone           string           `json:"phone,omitempty"`
	FirstName       string           `json:"first_name,omitempty"`
	MiddleName      string           `json:"middle_name,omitempty"`
	LastName        string           `json:"last_name,omitempty"`
	PayerId         string           `json:"payer_id,omitempty"`
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *PayerInfo) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var first = true

	if len(self.Email) != 0 {
		encoder.EncodeKeyVal("email", self.Email, first)
		first = false
	}

	if len(self.Salutation) != 0 {
		encoder.EncodeKeyVal("salutation", self.Salutation, first)
		first = false
	}

	if len(self.Suffix) != 0 {
		encoder.EncodeKeyVal("suffix", self.Suffix, first)
		first = false
	}

	encoder.EncodeKeyVal("country_code", self.CountryCode, first)
	first = false

	if len(self.Phone) != 0 {
		encoder.EncodeKeyVal("phone", self.Phone, first)
		first = false
	}

	if len(self.FirstName) != 0 {
		encoder.EncodeKeyVal("first_name", self.FirstName, first)
		first = false
	}

	if len(self.MiddleName) != 0 {
		encoder.EncodeKeyVal("middle_name", self.MiddleName, first)
		first = false
	}

	if len(self.LastName) != 0 {
		encoder.EncodeKeyVal("last_name", self.LastName, first)
		first = false
	}

	if len(self.PayerId) != 0 {
		encoder.EncodeKeyVal("payer_id", self.PayerId, first)
		first = false
	}

	if z, ok := interface{}(self.ShippingAddress).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("shipping_address", self.ShippingAddress, first)
		first = false
	}
	encoder.WriteRawByte('}')
}

func (self *PayerInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_6m1cp3rqht78{
		&self.private,
		self.Email,
		self.Salutation,
		self.Suffix,
		self.CountryCode,
		self.Phone,
		self.FirstName,
		self.MiddleName,
		self.LastName,
		self.PayerId,
		self.ShippingAddress,
	})
}

func (self *PayerInfo) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["email"]; ok {
		if err = json.Unmarshal(data, &self.Email); err != nil {
			return err
		}
	}

	if data, ok = m["salutation"]; ok {
		if err = json.Unmarshal(data, &self.Salutation); err != nil {
			return err
		}
	}

	if data, ok = m["suffix"]; ok {
		if err = json.Unmarshal(data, &self.Suffix); err != nil {
			return err
		}
	}

	if data, ok = m["country_code"]; ok {
		if err = json.Unmarshal(data, &self.CountryCode); err != nil {
			return err
		}
	}

	if data, ok = m["phone"]; ok {
		if err = json.Unmarshal(data, &self.Phone); err != nil {
			return err
		}
	}

	if data, ok = m["first_name"]; ok {
		if err = json.Unmarshal(data, &self.FirstName); err != nil {
			return err
		}
	}

	if data, ok = m["middle_name"]; ok {
		if err = json.Unmarshal(data, &self.MiddleName); err != nil {
			return err
		}
	}

	if data, ok = m["last_name"]; ok {
		if err = json.Unmarshal(data, &self.LastName); err != nil {
			return err
		}
	}

	if data, ok = m["payer_id"]; ok {
		if err = json.Unmarshal(data, &self.PayerId); err != nil {
			return err
		}
	}

	if data, ok = m["shipping_address"]; ok {
		if err = json.Unmarshal(data, &self.ShippingAddress); err != nil {
			return err
		}
	}
	return nil
}
