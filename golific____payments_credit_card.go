/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"Golific/gJson"
	"encoding/json"
	"reflect"
)

/*****************************

CreditCardPayment struct

******************************/

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *CreditCardPayment) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')
	var first = true

	if je, ok := interface{}(self.connection).(gJson.JSONEncodable); ok {
		first = !encoder.EmbedEncodedStruct(je, first) && first
	} else {
		first = !encoder.EmbedMarshaledStruct(self.connection, first) && first
	}

	if z, ok := interface{}(self.Intent).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.Intent

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.Intent).Kind() == reflect.Struct {
				d = &self.Intent
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("intent", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.State).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.State

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.State).Kind() == reflect.Struct {
				d = &self.State
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("state", d, first, true) && first
		}
	}

	if len(self.Id) != 0 {
		var d interface{} = self.Id

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.Id).Kind() == reflect.Struct {
				d = &self.Id
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("id", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.FailureReason).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.FailureReason

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.FailureReason).Kind() == reflect.Struct {
				d = &self.FailureReason
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("failure_reason", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.CreateTime).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.CreateTime

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.CreateTime).Kind() == reflect.Struct {
				d = &self.CreateTime
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("create_time", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.UpdateTime).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.UpdateTime

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.UpdateTime).Kind() == reflect.Struct {
				d = &self.UpdateTime
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("update_time", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.Links).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.Links

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.Links).Kind() == reflect.Struct {
				d = &self.Links
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("links", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.Transactions).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.Transactions

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.Transactions).Kind() == reflect.Struct {
				d = &self.Transactions
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("transactions", d, first, true) && first
		}
	}

	if true {
		var d interface{} = self.ExperienceProfileId

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.ExperienceProfileId).Kind() == reflect.Struct {
				d = &self.ExperienceProfileId
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("experience_profile_id", d, first, false) && first
		}
	}

	if z, ok := interface{}(self.Payer).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.Payer

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.Payer).Kind() == reflect.Struct {
				d = &self.Payer
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("payer", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.RedirectUrls).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.RedirectUrls

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.RedirectUrls).Kind() == reflect.Struct {
				d = &self.RedirectUrls
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("redirect_urls", d, first, true) && first
		}
	}

	if je, ok := interface{}(self.payment_error).(gJson.JSONEncodable); ok {
		first = !encoder.EmbedEncodedStruct(je, first) && first
	} else {
		first = !encoder.EmbedMarshaledStruct(self.payment_error, first) && first
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *CreditCardPayment) MarshalJSON() ([]byte, error) {
	var encoder gJson.Encoder
	self.JSONEncode(&encoder)
	return encoder.Bytes(), nil
}

func (self *CreditCardPayment) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// First unmarshal using the default unmarshaler. The temp type is so that
	// this method is not called recursively.
	type temp *CreditCardPayment
	if err := json.Unmarshal(j, temp(self)); err != nil {
		return err
	}

	return nil
}

/*****************************

CreditCardTransaction struct

******************************/

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *CreditCardTransaction) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')
	var first = true

	if z, ok := interface{}(self.ItemList).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.ItemList

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.ItemList).Kind() == reflect.Struct {
				d = &self.ItemList
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("item_list", d, first, true) && first
		}
	}

	if true {
		var d interface{} = self.Amount

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.Amount).Kind() == reflect.Struct {
				d = &self.Amount
			}
		}

		var doEncode = true
		if false { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("amount", d, first, false) && first
		}
	}

	if z, ok := interface{}(self.RelatedResources).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.RelatedResources

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.RelatedResources).Kind() == reflect.Struct {
				d = &self.RelatedResources
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("related_resources", d, first, true) && first
		}
	}

	if len(self.Description) != 0 {
		var d interface{} = self.Description

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.Description).Kind() == reflect.Struct {
				d = &self.Description
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("description", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.PaymentOptions).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.PaymentOptions

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.PaymentOptions).Kind() == reflect.Struct {
				d = &self.PaymentOptions
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("payment_options", d, first, true) && first
		}
	}

	if len(self.InvoiceNumber) != 0 {
		var d interface{} = self.InvoiceNumber

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.InvoiceNumber).Kind() == reflect.Struct {
				d = &self.InvoiceNumber
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("invoice_number", d, first, true) && first
		}
	}

	if len(self.Custom) != 0 {
		var d interface{} = self.Custom

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.Custom).Kind() == reflect.Struct {
				d = &self.Custom
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("custom", d, first, true) && first
		}
	}

	if len(self.SoftDescriptor) != 0 {
		var d interface{} = self.SoftDescriptor

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.SoftDescriptor).Kind() == reflect.Struct {
				d = &self.SoftDescriptor
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("soft_descriptor", d, first, true) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *CreditCardTransaction) MarshalJSON() ([]byte, error) {
	var encoder gJson.Encoder
	self.JSONEncode(&encoder)
	return encoder.Bytes(), nil
}

func (self *CreditCardTransaction) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// First unmarshal using the default unmarshaler. The temp type is so that
	// this method is not called recursively.
	type temp *CreditCardTransaction
	if err := json.Unmarshal(j, temp(self)); err != nil {
		return err
	}

	return nil
}

/*****************************

creditCardItemList struct

******************************/

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *creditCardItemList) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')
	var first = true

	if len(self.Items) != 0 {
		var d interface{} = self.Items

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.Items).Kind() == reflect.Struct {
				d = &self.Items
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("items", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.ShippingAddress).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.ShippingAddress

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.ShippingAddress).Kind() == reflect.Struct {
				d = &self.ShippingAddress
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("shipping_address", d, first, true) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *creditCardItemList) MarshalJSON() ([]byte, error) {
	var encoder gJson.Encoder
	self.JSONEncode(&encoder)
	return encoder.Bytes(), nil
}

func (self *creditCardItemList) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// First unmarshal using the default unmarshaler. The temp type is so that
	// this method is not called recursively.
	type temp *creditCardItemList
	if err := json.Unmarshal(j, temp(self)); err != nil {
		return err
	}

	return nil
}

/*****************************

creditCardPayer struct

******************************/

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *creditCardPayer) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')
	var first = true

	if z, ok := interface{}(self.PaymentMethod).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.PaymentMethod

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.PaymentMethod).Kind() == reflect.Struct {
				d = &self.PaymentMethod
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("payment_method", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.FundingInstruments).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.FundingInstruments

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.FundingInstruments).Kind() == reflect.Struct {
				d = &self.FundingInstruments
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("funding_instruments", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.PayerInfo).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.PayerInfo

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.PayerInfo).Kind() == reflect.Struct {
				d = &self.PayerInfo
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("payer_info", d, first, true) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *creditCardPayer) MarshalJSON() ([]byte, error) {
	var encoder gJson.Encoder
	self.JSONEncode(&encoder)
	return encoder.Bytes(), nil
}

func (self *creditCardPayer) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// First unmarshal using the default unmarshaler. The temp type is so that
	// this method is not called recursively.
	type temp *creditCardPayer
	if err := json.Unmarshal(j, temp(self)); err != nil {
		return err
	}

	return nil
}

/*****************************

PayerInfo struct

******************************/

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *PayerInfo) JSONEncode(encoder *gJson.Encoder) bool {
	if self == nil {
		return encoder.EncodeNull(false)
	}

	encoder.WriteRawByte('{')
	var first = true

	if len(self.Email) != 0 {
		var d interface{} = self.Email

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.Email).Kind() == reflect.Struct {
				d = &self.Email
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("email", d, first, true) && first
		}
	}

	if len(self.Salutation) != 0 {
		var d interface{} = self.Salutation

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.Salutation).Kind() == reflect.Struct {
				d = &self.Salutation
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("salutation", d, first, true) && first
		}
	}

	if len(self.Suffix) != 0 {
		var d interface{} = self.Suffix

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.Suffix).Kind() == reflect.Struct {
				d = &self.Suffix
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("suffix", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.CountryCode).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.CountryCode

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.CountryCode).Kind() == reflect.Struct {
				d = &self.CountryCode
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("country_code", d, first, true) && first
		}
	}

	if len(self.Phone) != 0 {
		var d interface{} = self.Phone

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.Phone).Kind() == reflect.Struct {
				d = &self.Phone
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("phone", d, first, true) && first
		}
	}

	if len(self.FirstName) != 0 {
		var d interface{} = self.FirstName

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.FirstName).Kind() == reflect.Struct {
				d = &self.FirstName
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("first_name", d, first, true) && first
		}
	}

	if len(self.MiddleName) != 0 {
		var d interface{} = self.MiddleName

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.MiddleName).Kind() == reflect.Struct {
				d = &self.MiddleName
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("middle_name", d, first, true) && first
		}
	}

	if len(self.LastName) != 0 {
		var d interface{} = self.LastName

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.LastName).Kind() == reflect.Struct {
				d = &self.LastName
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("last_name", d, first, true) && first
		}
	}

	if len(self.PayerId) != 0 {
		var d interface{} = self.PayerId

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if false && reflect.ValueOf(self.PayerId).Kind() == reflect.Struct {
				d = &self.PayerId
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("payer_id", d, first, true) && first
		}
	}

	if z, ok := interface{}(self.ShippingAddress).(gJson.Zeroable); !ok || !z.IsZero() {
		var d interface{} = self.ShippingAddress

		if _, ok := d.(gJson.JSONEncodable); !ok {
			if true && reflect.ValueOf(self.ShippingAddress).Kind() == reflect.Struct {
				d = &self.ShippingAddress
			}
		}

		var doEncode = true
		if true { // has omitempty?
			if zer, okCanZero := d.(gJson.Zeroable); okCanZero {
				doEncode = !zer.IsZero()
			}
		}

		if doEncode {
			first = !encoder.EncodeKeyVal("shipping_address", d, first, true) && first
		}
	}

	encoder.WriteRawByte('}')

	return true || !first
}

func (self *PayerInfo) MarshalJSON() ([]byte, error) {
	var encoder gJson.Encoder
	self.JSONEncode(&encoder)
	return encoder.Bytes(), nil
}

func (self *PayerInfo) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// First unmarshal using the default unmarshaler. The temp type is so that
	// this method is not called recursively.
	type temp *PayerInfo
	if err := json.Unmarshal(j, temp(self)); err != nil {
		return err
	}

	return nil
}
