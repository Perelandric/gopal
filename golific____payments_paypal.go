/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"Golific/gJson"
	"encoding/json"
	"strings"
)

/*****************************

PaypalPayment struct

******************************/

type PaypalPayment struct {
	private private_v7j56lzi42nn
	*connection
	ExperienceProfileId string `json:"experience_profile_id,omitempty"`
	*payment_error
}

type private_v7j56lzi42nn struct {
	Intent        intentEnum         `json:"intent,omitempty"`
	State         *StateEnum         `json:"state,omitempty"`
	Id            string             `json:"id,omitempty"`
	FailureReason *FailureReasonEnum `json:"failure_reason,omitempty"`
	CreateTime    dateTime           `json:"create_time,omitempty"`
	UpdateTime    dateTime           `json:"update_time,omitempty"`
	Links         links              `json:"links,omitempty"`
	Transactions  PaypalTransactions `json:"transactions,omitempty"`
	Payer         paypalPayer        `json:"payer,omitempty"`
	RedirectUrls  Redirects          `json:"redirect_urls,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_v7j56lzi42nn) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("intent", self.Intent, first)
	first = false

	if z, ok := interface{}(self.State).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("state", self.State, first)
		first = false
	}

	if len(self.Id) != 0 {
		encoder.EncodeKeyVal("id", self.Id, first)
		first = false
	}

	if z, ok := interface{}(self.FailureReason).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("failure_reason", self.FailureReason, first)
		first = false
	}

	encoder.EncodeKeyVal("create_time", self.CreateTime, first)
	first = false

	encoder.EncodeKeyVal("update_time", self.UpdateTime, first)
	first = false

	encoder.EncodeKeyVal("links", self.Links, first)
	first = false

	encoder.EncodeKeyVal("transactions", self.Transactions, first)
	first = false

	encoder.EncodeKeyVal("payer", self.Payer, first)
	first = false

	encoder.EncodeKeyVal("redirect_urls", self.RedirectUrls, first)
	first = false
}

type json_v7j56lzi42nn struct {
	*private_v7j56lzi42nn
	*connection
	ExperienceProfileId string `json:"experience_profile_id,omitempty"`
	*payment_error
}

func (self *PaypalPayment) Intent() intentEnum {
	return self.private.Intent
}

func (self *PaypalPayment) State() *StateEnum {
	return self.private.State
}

func (self *PaypalPayment) Id() string {
	return self.private.Id
}

func (self *PaypalPayment) FailureReason() *FailureReasonEnum {
	return self.private.FailureReason
}

func (self *PaypalPayment) CreateTime() dateTime {
	return self.private.CreateTime
}

func (self *PaypalPayment) UpdateTime() dateTime {
	return self.private.UpdateTime
}

func (self *PaypalPayment) Links() links {
	return self.private.Links
}

func (self *PaypalPayment) Transactions() PaypalTransactions {
	return self.private.Transactions
}

func (self *PaypalPayment) Payer() paypalPayer {
	return self.private.Payer
}

func (self *PaypalPayment) RedirectUrls() Redirects {
	return self.private.RedirectUrls
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *PaypalPayment) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	if je, ok := interface{}(self.connection).(gJson.JSONEncodable); ok {
		first = encoder.EmbedEncodedStruct(je, first)
	} else {
		first = encoder.EmbedMarshaledStruct(self.connection, first)
	}

	if len(self.ExperienceProfileId) != 0 {
		encoder.EncodeKeyVal("experience_profile_id", self.ExperienceProfileId, first)
		first = false
	}

	if je, ok := interface{}(self.payment_error).(gJson.JSONEncodable); ok {
		first = encoder.EmbedEncodedStruct(je, first)
	} else {
		first = encoder.EmbedMarshaledStruct(self.payment_error, first)
	}

	encoder.WriteRawByte('}')
}

func (self *PaypalPayment) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_v7j56lzi42nn{
		&self.private,
		self.connection,
		self.ExperienceProfileId,
		self.payment_error,
	})
}

func (self *PaypalPayment) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["intent"]; ok {
		if err = json.Unmarshal(data, &self.private.Intent); err != nil {
			return err
		}
	}

	if data, ok = m["state"]; ok {
		if err = json.Unmarshal(data, &self.private.State); err != nil {
			return err
		}
	}

	if data, ok = m["id"]; ok {
		if err = json.Unmarshal(data, &self.private.Id); err != nil {
			return err
		}
	}

	if data, ok = m["failure_reason"]; ok {
		if err = json.Unmarshal(data, &self.private.FailureReason); err != nil {
			return err
		}
	}

	if data, ok = m["create_time"]; ok {
		if err = json.Unmarshal(data, &self.private.CreateTime); err != nil {
			return err
		}
	}

	if data, ok = m["update_time"]; ok {
		if err = json.Unmarshal(data, &self.private.UpdateTime); err != nil {
			return err
		}
	}

	if data, ok = m["links"]; ok {
		if err = json.Unmarshal(data, &self.private.Links); err != nil {
			return err
		}
	}

	if data, ok = m["transactions"]; ok {
		if err = json.Unmarshal(data, &self.private.Transactions); err != nil {
			return err
		}
	}

	if data, ok = m["payer"]; ok {
		if err = json.Unmarshal(data, &self.private.Payer); err != nil {
			return err
		}
	}

	if data, ok = m["redirect_urls"]; ok {
		if err = json.Unmarshal(data, &self.private.RedirectUrls); err != nil {
			return err
		}
	}

	if data, ok = m["experience_profile_id"]; ok {
		if err = json.Unmarshal(data, &self.ExperienceProfileId); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

PaypalTransaction struct

******************************/

type PaypalTransaction struct {
	private        private_1aalucxe35skh
	Description    string          `json:"description,omitempty"`
	PaymentOptions *paymentOptions `json:"payment_options,omitempty"`
	InvoiceNumber  string          `json:"invoice_number,omitempty"`
	Custom         string          `json:"custom,omitempty"`
	SoftDescriptor string          `json:"soft_descriptor,omitempty"`
}

type private_1aalucxe35skh struct {
	ItemList         *paypalItemList  `json:"item_list,omitempty"`
	Amount           amount           `json:"amount"`
	RelatedResources relatedResources `json:"related_resources,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1aalucxe35skh) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	if z, ok := interface{}(self.ItemList).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("item_list", self.ItemList, first)
		first = false
	}

	encoder.EncodeKeyVal("amount", self.Amount, first)
	first = false

	encoder.EncodeKeyVal("related_resources", self.RelatedResources, first)
	first = false
}

type json_1aalucxe35skh struct {
	*private_1aalucxe35skh
	Description    string          `json:"description,omitempty"`
	PaymentOptions *paymentOptions `json:"payment_options,omitempty"`
	InvoiceNumber  string          `json:"invoice_number,omitempty"`
	Custom         string          `json:"custom,omitempty"`
	SoftDescriptor string          `json:"soft_descriptor,omitempty"`
}

func (self *PaypalTransaction) ItemList() *paypalItemList {
	return self.private.ItemList
}

func (self *PaypalTransaction) Amount() amount {
	return self.private.Amount
}

func (self *PaypalTransaction) RelatedResources() relatedResources {
	return self.private.RelatedResources
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *PaypalTransaction) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	if len(self.Description) != 0 {
		encoder.EncodeKeyVal("description", self.Description, first)
		first = false
	}

	if z, ok := interface{}(self.PaymentOptions).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("payment_options", self.PaymentOptions, first)
		first = false
	}

	if len(self.InvoiceNumber) != 0 {
		encoder.EncodeKeyVal("invoice_number", self.InvoiceNumber, first)
		first = false
	}

	if len(self.Custom) != 0 {
		encoder.EncodeKeyVal("custom", self.Custom, first)
		first = false
	}

	if len(self.SoftDescriptor) != 0 {
		encoder.EncodeKeyVal("soft_descriptor", self.SoftDescriptor, first)
		first = false
	}
	encoder.WriteRawByte('}')
}

func (self *PaypalTransaction) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1aalucxe35skh{
		&self.private,
		self.Description,
		self.PaymentOptions,
		self.InvoiceNumber,
		self.Custom,
		self.SoftDescriptor,
	})
}

func (self *PaypalTransaction) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["item_list"]; ok {
		if err = json.Unmarshal(data, &self.private.ItemList); err != nil {
			return err
		}
	}

	if data, ok = m["amount"]; ok {
		if err = json.Unmarshal(data, &self.private.Amount); err != nil {
			return err
		}
	}

	if data, ok = m["related_resources"]; ok {
		if err = json.Unmarshal(data, &self.private.RelatedResources); err != nil {
			return err
		}
	}

	if data, ok = m["description"]; ok {
		if err = json.Unmarshal(data, &self.Description); err != nil {
			return err
		}
	}

	if data, ok = m["payment_options"]; ok {
		if err = json.Unmarshal(data, &self.PaymentOptions); err != nil {
			return err
		}
	}

	if data, ok = m["invoice_number"]; ok {
		if err = json.Unmarshal(data, &self.InvoiceNumber); err != nil {
			return err
		}
	}

	if data, ok = m["custom"]; ok {
		if err = json.Unmarshal(data, &self.Custom); err != nil {
			return err
		}
	}

	if data, ok = m["soft_descriptor"]; ok {
		if err = json.Unmarshal(data, &self.SoftDescriptor); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

paypalItemList struct

******************************/

type paypalItemList struct {
	private private_ow1tyl6momvu
}

type private_ow1tyl6momvu struct {
	Items           PaypalItems      `json:"items,omitempty"`
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_ow1tyl6momvu) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("items", self.Items, first)
	first = false

	if z, ok := interface{}(self.ShippingAddress).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("shipping_address", self.ShippingAddress, first)
		first = false
	}
}

type json_ow1tyl6momvu struct {
	*private_ow1tyl6momvu
}

func (self *paypalItemList) Items() PaypalItems {
	return self.private.Items
}

func (self *paypalItemList) ShippingAddress() *ShippingAddress {
	return self.private.ShippingAddress
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *paypalItemList) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	encoder.WriteRawByte('}')
}

func (self *paypalItemList) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_ow1tyl6momvu{
		&self.private,
	})
}

func (self *paypalItemList) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["items"]; ok {
		if err = json.Unmarshal(data, &self.private.Items); err != nil {
			return err
		}
	}

	if data, ok = m["shipping_address"]; ok {
		if err = json.Unmarshal(data, &self.private.ShippingAddress); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

paypalPayer struct

******************************/

// Source of the funds for this payment represented by a PayPal account.
type paypalPayer struct {
	private private_1g5iqhg8ry1x9
}

type private_1g5iqhg8ry1x9 struct {
	// Must be PaymentMethod.Paypal
	PaymentMethod PaymentMethodEnum `json:"payment_method,omitempty"`
	// Status of the payer’s PayPal account. Allowed values: VERIFIED or UNVERIFIED.
	Status          *payerStatusEnum `json:"status,omitempty"`
	PaypalPayerInfo *PaypalPayerInfo `json:"payer_info,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_1g5iqhg8ry1x9) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	encoder.EncodeKeyVal("payment_method", self.PaymentMethod, first)
	first = false

	if z, ok := interface{}(self.Status).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("status", self.Status, first)
		first = false
	}

	if z, ok := interface{}(self.PaypalPayerInfo).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("payer_info", self.PaypalPayerInfo, first)
		first = false
	}
}

type json_1g5iqhg8ry1x9 struct {
	*private_1g5iqhg8ry1x9
}

func (self *paypalPayer) Status() *payerStatusEnum {
	return self.private.Status
}

func (self *paypalPayer) PaypalPayerInfo() *PaypalPayerInfo {
	return self.private.PaypalPayerInfo
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *paypalPayer) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	encoder.WriteRawByte('}')
}

func (self *paypalPayer) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1g5iqhg8ry1x9{
		&self.private,
	})
}

func (self *paypalPayer) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["payment_method"]; ok {
		if err = json.Unmarshal(data, &self.private.PaymentMethod); err != nil {
			return err
		}
	}

	if data, ok = m["status"]; ok {
		if err = json.Unmarshal(data, &self.private.Status); err != nil {
			return err
		}
	}

	if data, ok = m["payer_info"]; ok {
		if err = json.Unmarshal(data, &self.private.PaypalPayerInfo); err != nil {
			return err
		}
	}
	return nil
}

/*****************************

PaypalPayerInfo struct

******************************/

// This object is pre-filled by PayPal when the payment_method is paypal.
type PaypalPayerInfo struct {
	private private_wonhmtsy5vcp
	// Payer’s tax ID type. Allowed values: BR_CPF or BR_C`NPJ. Only supported when
	// the payment_method is set to paypal.
	TaxIdType TaxIdTypeEnum `json:"tax_id_type,omitempty"`
	// Payer’s tax ID. Only supported when the payment_method is set to paypal.
	TaxId string `json:"tax_id,omitempty"`
}

type private_wonhmtsy5vcp struct {
	// Email address representing the payer. 127 characters max.
	Email string `json:"email,omitempty"`
	// Salutation of the payer.
	Salutation string `json:"salutation,omitempty"`
	// Suffix of the payer.
	Suffix string `json:"suffix,omitempty"`
	// Two-letter registered country code of the payer to identify the buyer country.
	CountryCode CountryCodeEnum `json:"country_code,omitempty"`
	// Phone number representing the payer. 20 characters max.
	Phone string `json:"phone,omitempty"`
	// First name of the payer. Value assigned by PayPal.
	FirstName string `json:"first_name,omitempty"`
	// Middle name of the payer. Value assigned by PayPal.
	MiddleName string `json:"middle_name,omitempty"`
	// Last name of the payer. Value assigned by PayPal.
	LastName string `json:"last_name,omitempty"`
	// PayPal assigned Payer ID. Value assigned by PayPal.
	PayerId string `json:"payer_id,omitempty"`
	// Shipping address of payer PayPal account. Value assigned by PayPal.
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *private_wonhmtsy5vcp) JSONEncode(encoder *gJson.Encoder) {
	var first = true
	if len(self.Email) != 0 {
		encoder.EncodeKeyVal("email", self.Email, first)
		first = false
	}

	if len(self.Salutation) != 0 {
		encoder.EncodeKeyVal("salutation", self.Salutation, first)
		first = false
	}

	if len(self.Suffix) != 0 {
		encoder.EncodeKeyVal("suffix", self.Suffix, first)
		first = false
	}

	encoder.EncodeKeyVal("country_code", self.CountryCode, first)
	first = false

	if len(self.Phone) != 0 {
		encoder.EncodeKeyVal("phone", self.Phone, first)
		first = false
	}

	if len(self.FirstName) != 0 {
		encoder.EncodeKeyVal("first_name", self.FirstName, first)
		first = false
	}

	if len(self.MiddleName) != 0 {
		encoder.EncodeKeyVal("middle_name", self.MiddleName, first)
		first = false
	}

	if len(self.LastName) != 0 {
		encoder.EncodeKeyVal("last_name", self.LastName, first)
		first = false
	}

	if len(self.PayerId) != 0 {
		encoder.EncodeKeyVal("payer_id", self.PayerId, first)
		first = false
	}

	if z, ok := interface{}(self.ShippingAddress).(gJson.Zeroable); !ok || !z.IsZero() {
		encoder.EncodeKeyVal("shipping_address", self.ShippingAddress, first)
		first = false
	}
}

type json_wonhmtsy5vcp struct {
	*private_wonhmtsy5vcp
	TaxIdType TaxIdTypeEnum `json:"tax_id_type,omitempty"`
	TaxId     string        `json:"tax_id,omitempty"`
}

func (self *PaypalPayerInfo) Email() string {
	return self.private.Email
}

func (self *PaypalPayerInfo) Salutation() string {
	return self.private.Salutation
}

func (self *PaypalPayerInfo) Suffix() string {
	return self.private.Suffix
}

func (self *PaypalPayerInfo) CountryCode() CountryCodeEnum {
	return self.private.CountryCode
}

func (self *PaypalPayerInfo) Phone() string {
	return self.private.Phone
}

func (self *PaypalPayerInfo) FirstName() string {
	return self.private.FirstName
}

func (self *PaypalPayerInfo) MiddleName() string {
	return self.private.MiddleName
}

func (self *PaypalPayerInfo) LastName() string {
	return self.private.LastName
}

func (self *PaypalPayerInfo) PayerId() string {
	return self.private.PayerId
}

func (self *PaypalPayerInfo) ShippingAddress() *ShippingAddress {
	return self.private.ShippingAddress
}

// JSONEncode implements part of Golific's JSONEncodable interface.
func (self *PaypalPayerInfo) JSONEncode(encoder *gJson.Encoder) {
	encoder.WriteRawByte('{')

	var startPos = encoder.Len()

	// Encodes only the fields of the struct, without curly braces
	self.private.JSONEncode(encoder)

	var first = encoder.Len() == startPos

	encoder.EncodeKeyVal("tax_id_type", self.TaxIdType, first)
	first = false

	if len(self.TaxId) != 0 {
		encoder.EncodeKeyVal("tax_id", self.TaxId, first)
		first = false
	}
	encoder.WriteRawByte('}')
}

func (self *PaypalPayerInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_wonhmtsy5vcp{
		&self.private,
		self.TaxIdType,
		self.TaxId,
	})
}

func (self *PaypalPayerInfo) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// JSON key comparisons are case-insensitive
	for k, v := range m {
		m[strings.ToLower(k)] = v
	}

	var data json.RawMessage
	var ok bool
	if data, ok = m["tax_id_type"]; ok {
		if err = json.Unmarshal(data, &self.TaxIdType); err != nil {
			return err
		}
	}

	if data, ok = m["tax_id"]; ok {
		if err = json.Unmarshal(data, &self.TaxId); err != nil {
			return err
		}
	}

	if data, ok = m["email"]; ok {
		if err = json.Unmarshal(data, &self.private.Email); err != nil {
			return err
		}
	}

	if data, ok = m["salutation"]; ok {
		if err = json.Unmarshal(data, &self.private.Salutation); err != nil {
			return err
		}
	}

	if data, ok = m["suffix"]; ok {
		if err = json.Unmarshal(data, &self.private.Suffix); err != nil {
			return err
		}
	}

	if data, ok = m["country_code"]; ok {
		if err = json.Unmarshal(data, &self.private.CountryCode); err != nil {
			return err
		}
	}

	if data, ok = m["phone"]; ok {
		if err = json.Unmarshal(data, &self.private.Phone); err != nil {
			return err
		}
	}

	if data, ok = m["first_name"]; ok {
		if err = json.Unmarshal(data, &self.private.FirstName); err != nil {
			return err
		}
	}

	if data, ok = m["middle_name"]; ok {
		if err = json.Unmarshal(data, &self.private.MiddleName); err != nil {
			return err
		}
	}

	if data, ok = m["last_name"]; ok {
		if err = json.Unmarshal(data, &self.private.LastName); err != nil {
			return err
		}
	}

	if data, ok = m["payer_id"]; ok {
		if err = json.Unmarshal(data, &self.private.PayerId); err != nil {
			return err
		}
	}

	if data, ok = m["shipping_address"]; ok {
		if err = json.Unmarshal(data, &self.private.ShippingAddress); err != nil {
			return err
		}
	}
	return nil
}
