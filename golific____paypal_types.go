/****************************************************************************
	This file was generated by Golific.

	Do not edit this file. If you do, your changes will be overwritten the next
	time 'generate' is invoked.
******************************************************************************/

package gopal

import (
	"encoding/json"
)

/*****************************

PaypalPayment struct

******************************/
func NewPaypalPayment() *PaypalPayment {
	return &PaypalPayment{
		private: private_fg9ic0pru0qp{},
	}
}

// TODO: Add `billing_agreement_tokens`, `payment_instruction`
type PaypalPayment struct {
	private private_fg9ic0pru0qp
	*connection
	ExperienceProfileId string `json:"experience_profile_id,omitempty"`
	*payment_error
}

type private_fg9ic0pru0qp struct {
	Intent        intentEnum         `json:"intent,omitempty"`
	State         *stateEnum         `json:"state,omitempty"`
	Id            string             `json:"id,omitempty"`
	FailureReason *FailureReasonEnum `json:"failure_reason,omitempty"`
	CreateTime    dateTime           `json:"create_time,omitempty"`
	UpdateTime    dateTime           `json:"update_time,omitempty"`
	Links         links              `json:"links,omitempty"`
	Transactions  PaypalTransactions `json:"transactions,omitempty"`
	Payer         paypalPayer        `json:"payer,omitempty"`
	RedirectUrls  Redirects          `json:"redirect_urls,omitempty"`
}

type json_fg9ic0pru0qp struct {
	*private_fg9ic0pru0qp
	*connection
	ExperienceProfileId string `json:"experience_profile_id,omitempty"`
	*payment_error
}

func (self *PaypalPayment) Intent() intentEnum {
	return self.private.Intent
}

func (self *PaypalPayment) State() *stateEnum {
	return self.private.State
}

func (self *PaypalPayment) Id() string {
	return self.private.Id
}

func (self *PaypalPayment) FailureReason() *FailureReasonEnum {
	return self.private.FailureReason
}

func (self *PaypalPayment) CreateTime() dateTime {
	return self.private.CreateTime
}

func (self *PaypalPayment) UpdateTime() dateTime {
	return self.private.UpdateTime
}

func (self *PaypalPayment) Links() links {
	return self.private.Links
}

func (self *PaypalPayment) Transactions() PaypalTransactions {
	return self.private.Transactions
}

func (self *PaypalPayment) Payer() paypalPayer {
	return self.private.Payer
}

func (self *PaypalPayment) RedirectUrls() Redirects {
	return self.private.RedirectUrls
}

func (self *PaypalPayment) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_fg9ic0pru0qp{
		&self.private,
		self.connection,
		self.ExperienceProfileId,
		self.payment_error,
	})
}

func (self *PaypalPayment) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "intent":
			err = json.Unmarshal(rawMsg, &self.private.Intent)
		case "state":
			err = json.Unmarshal(rawMsg, &self.private.State)
		case "id":
			err = json.Unmarshal(rawMsg, &self.private.Id)
		case "failure_reason":
			err = json.Unmarshal(rawMsg, &self.private.FailureReason)
		case "create_time":
			err = json.Unmarshal(rawMsg, &self.private.CreateTime)
		case "update_time":
			err = json.Unmarshal(rawMsg, &self.private.UpdateTime)
		case "links":
			err = json.Unmarshal(rawMsg, &self.private.Links)
		case "transactions":
			err = json.Unmarshal(rawMsg, &self.private.Transactions)
		case "payer":
			err = json.Unmarshal(rawMsg, &self.private.Payer)
		case "redirect_urls":
			err = json.Unmarshal(rawMsg, &self.private.RedirectUrls)
		case "experience_profile_id":
			err = json.Unmarshal(rawMsg, &self.ExperienceProfileId)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

PaypalTransaction struct

******************************/
func NewPaypalTransaction() *PaypalTransaction {
	return &PaypalTransaction{
		private: private_40913pqrmgku{},
	}
}

type PaypalTransaction struct {
	private        private_40913pqrmgku
	Description    string          `json:"description,omitempty"`
	PaymentOptions *paymentOptions `json:"payment_options,omitempty"`
	InvoiceNumber  string          `json:"invoice_number,omitempty"`
	Custom         string          `json:"custom,omitempty"`
	SoftDescriptor string          `json:"soft_descriptor,omitempty"`
}

type private_40913pqrmgku struct {
	ItemList         *paypalItemList  `json:"item_list,omitempty"`
	Amount           amount           `json:"amount"`
	RelatedResources relatedResources `json:"related_resources,omitempty"`
}

type json_40913pqrmgku struct {
	*private_40913pqrmgku
	Description    string          `json:"description,omitempty"`
	PaymentOptions *paymentOptions `json:"payment_options,omitempty"`
	InvoiceNumber  string          `json:"invoice_number,omitempty"`
	Custom         string          `json:"custom,omitempty"`
	SoftDescriptor string          `json:"soft_descriptor,omitempty"`
}

func (self *PaypalTransaction) ItemList() *paypalItemList {
	return self.private.ItemList
}

func (self *PaypalTransaction) Amount() amount {
	return self.private.Amount
}

func (self *PaypalTransaction) RelatedResources() relatedResources {
	return self.private.RelatedResources
}

func (self *PaypalTransaction) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_40913pqrmgku{
		&self.private,
		self.Description,
		self.PaymentOptions,
		self.InvoiceNumber,
		self.Custom,
		self.SoftDescriptor,
	})
}

func (self *PaypalTransaction) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "item_list":
			err = json.Unmarshal(rawMsg, &self.private.ItemList)
		case "amount":
			err = json.Unmarshal(rawMsg, &self.private.Amount)
		case "related_resources":
			err = json.Unmarshal(rawMsg, &self.private.RelatedResources)
		case "description":
			err = json.Unmarshal(rawMsg, &self.Description)
		case "payment_options":
			err = json.Unmarshal(rawMsg, &self.PaymentOptions)
		case "invoice_number":
			err = json.Unmarshal(rawMsg, &self.InvoiceNumber)
		case "custom":
			err = json.Unmarshal(rawMsg, &self.Custom)
		case "soft_descriptor":
			err = json.Unmarshal(rawMsg, &self.SoftDescriptor)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

paypalItemList struct

******************************/
func NewPaypalItemList() *paypalItemList {
	return &paypalItemList{
		private: private_a86cw1xf8j5n{},
	}
}

type paypalItemList struct {
	private private_a86cw1xf8j5n
}

type private_a86cw1xf8j5n struct {
	Items           PaypalItems      `json:"items,omitempty"`
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

type json_a86cw1xf8j5n struct {
	*private_a86cw1xf8j5n
}

func (self *paypalItemList) Items() PaypalItems {
	return self.private.Items
}

func (self *paypalItemList) ShippingAddress() *ShippingAddress {
	return self.private.ShippingAddress
}

func (self *paypalItemList) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_a86cw1xf8j5n{
		&self.private,
	})
}

func (self *paypalItemList) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "items":
			err = json.Unmarshal(rawMsg, &self.private.Items)
		case "shipping_address":
			err = json.Unmarshal(rawMsg, &self.private.ShippingAddress)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

PaypalItem struct

******************************/
func NewPaypalItem() *PaypalItem {
	return &PaypalItem{
		private: private_kxqnl4d878u7{},
	}
}

type PaypalItem struct {
	private     private_kxqnl4d878u7
	Quantity    int64   `json:"quantity,string"`
	Name        string  `json:"name"`
	Price       float64 `json:"price,string"`
	Tax         float64 `json:"tax,omitempty"`
	Sku         string  `json:"sku,omitempty"`
	Description string  `json:"description,omitempty"`
}

type private_kxqnl4d878u7 struct {
	Currency CurrencyTypeEnum `json:"currency"`
}

type json_kxqnl4d878u7 struct {
	*private_kxqnl4d878u7
	Quantity    int64   `json:"quantity,string"`
	Name        string  `json:"name"`
	Price       float64 `json:"price,string"`
	Tax         float64 `json:"tax,omitempty"`
	Sku         string  `json:"sku,omitempty"`
	Description string  `json:"description,omitempty"`
}

func (self *PaypalItem) Currency() CurrencyTypeEnum {
	return self.private.Currency
}

func (self *PaypalItem) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_kxqnl4d878u7{
		&self.private,
		self.Quantity,
		self.Name,
		self.Price,
		self.Tax,
		self.Sku,
		self.Description,
	})
}

func (self *PaypalItem) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "currency":
			err = json.Unmarshal(rawMsg, &self.private.Currency)
		case "quantity":
			err = json.Unmarshal(rawMsg, &self.Quantity)
		case "name":
			err = json.Unmarshal(rawMsg, &self.Name)
		case "price":
			err = json.Unmarshal(rawMsg, &self.Price)
		case "tax":
			err = json.Unmarshal(rawMsg, &self.Tax)
		case "sku":
			err = json.Unmarshal(rawMsg, &self.Sku)
		case "description":
			err = json.Unmarshal(rawMsg, &self.Description)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

paypalPayer struct

******************************/
func NewPaypalPayer() *paypalPayer {
	return &paypalPayer{
		private: private_1ia947xwngmrr{},
	}
}

// Source of the funds for this payment represented by a PayPal account.
type paypalPayer struct {
	private private_1ia947xwngmrr
}

type private_1ia947xwngmrr struct {
	// Must be PaymentMethod.Paypal
	PaymentMethod PaymentMethodEnum `json:"payment_method,omitempty"`
	// Status of the payer’s PayPal account. Allowed values: VERIFIED or UNVERIFIED.
	Status          *payerStatusEnum `json:"status,omitempty"`
	PaypalPayerInfo *PaypalPayerInfo `json:"payer_info,omitempty"`
}

type json_1ia947xwngmrr struct {
	*private_1ia947xwngmrr
}

func (self *paypalPayer) Status() *payerStatusEnum {
	return self.private.Status
}

func (self *paypalPayer) PaypalPayerInfo() *PaypalPayerInfo {
	return self.private.PaypalPayerInfo
}

func (self *paypalPayer) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_1ia947xwngmrr{
		&self.private,
	})
}

func (self *paypalPayer) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "payment_method":
			err = json.Unmarshal(rawMsg, &self.private.PaymentMethod)
		case "status":
			err = json.Unmarshal(rawMsg, &self.private.Status)
		case "payer_info":
			err = json.Unmarshal(rawMsg, &self.private.PaypalPayerInfo)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}

/*****************************

PaypalPayerInfo struct

******************************/
func NewPaypalPayerInfo() *PaypalPayerInfo {
	return &PaypalPayerInfo{
		private: private_p3zaxv9b3fb5{},
	}
}

// This object is pre-filled by PayPal when the payment_method is paypal.
type PaypalPayerInfo struct {
	private private_p3zaxv9b3fb5
	// Payer’s tax ID type. Allowed values: BR_CPF or BR_C`NPJ. Only supported when
	// the payment_method is set to paypal.
	TaxIdType TaxIdTypeEnum `json:"tax_id_type,omitempty"`
	// Payer’s tax ID. Only supported when the payment_method is set to paypal.
	TaxId string `json:"tax_id,omitempty"`
}

type private_p3zaxv9b3fb5 struct {
	// Email address representing the payer. 127 characters max.
	Email string `json:"email,omitempty"`
	// Salutation of the payer.
	Salutation string `json:"salutation,omitempty"`
	// Suffix of the payer.
	Suffix string `json:"suffix,omitempty"`
	// Two-letter registered country code of the payer to identify the buyer country.
	CountryCode CountryCodeEnum `json:"country_code,omitempty"`
	// Phone number representing the payer. 20 characters max.
	Phone string `json:"phone,omitempty"`
	// First name of the payer. Value assigned by PayPal.
	FirstName string `json:"first_name,omitempty"`
	// Middle name of the payer. Value assigned by PayPal.
	MiddleName string `json:"middle_name,omitempty"`
	// Last name of the payer. Value assigned by PayPal.
	LastName string `json:"last_name,omitempty"`
	// PayPal assigned Payer ID. Value assigned by PayPal.
	PayerId string `json:"payer_id,omitempty"`
	// Shipping address of payer PayPal account. Value assigned by PayPal.
	ShippingAddress *ShippingAddress `json:"shipping_address,omitempty"`
}

type json_p3zaxv9b3fb5 struct {
	*private_p3zaxv9b3fb5
	TaxIdType TaxIdTypeEnum `json:"tax_id_type,omitempty"`
	TaxId     string        `json:"tax_id,omitempty"`
}

func (self *PaypalPayerInfo) Email() string {
	return self.private.Email
}

func (self *PaypalPayerInfo) Salutation() string {
	return self.private.Salutation
}

func (self *PaypalPayerInfo) Suffix() string {
	return self.private.Suffix
}

func (self *PaypalPayerInfo) CountryCode() CountryCodeEnum {
	return self.private.CountryCode
}

func (self *PaypalPayerInfo) Phone() string {
	return self.private.Phone
}

func (self *PaypalPayerInfo) FirstName() string {
	return self.private.FirstName
}

func (self *PaypalPayerInfo) MiddleName() string {
	return self.private.MiddleName
}

func (self *PaypalPayerInfo) LastName() string {
	return self.private.LastName
}

func (self *PaypalPayerInfo) PayerId() string {
	return self.private.PayerId
}

func (self *PaypalPayerInfo) ShippingAddress() *ShippingAddress {
	return self.private.ShippingAddress
}

func (self *PaypalPayerInfo) MarshalJSON() ([]byte, error) {
	return json.Marshal(json_p3zaxv9b3fb5{
		&self.private,
		self.TaxIdType,
		self.TaxId,
	})
}

func (self *PaypalPayerInfo) UnmarshalJSON(j []byte) error {
	if len(j) == 4 && string(j) == "null" {
		return nil
	}

	m := make(map[string]json.RawMessage)

	err := json.Unmarshal(j, &m)
	if err != nil {
		return err
	}

	// For every property found, perform a separate UnmarshalJSON operation. This
	// prevents overwrite of values in 'self' where properties are absent.
	for key, rawMsg := range m {
		switch key {
		case "tax_id_type":
			err = json.Unmarshal(rawMsg, &self.TaxIdType)
		case "tax_id":
			err = json.Unmarshal(rawMsg, &self.TaxId)
		case "email":
			err = json.Unmarshal(rawMsg, &self.private.Email)
		case "salutation":
			err = json.Unmarshal(rawMsg, &self.private.Salutation)
		case "suffix":
			err = json.Unmarshal(rawMsg, &self.private.Suffix)
		case "country_code":
			err = json.Unmarshal(rawMsg, &self.private.CountryCode)
		case "phone":
			err = json.Unmarshal(rawMsg, &self.private.Phone)
		case "first_name":
			err = json.Unmarshal(rawMsg, &self.private.FirstName)
		case "middle_name":
			err = json.Unmarshal(rawMsg, &self.private.MiddleName)
		case "last_name":
			err = json.Unmarshal(rawMsg, &self.private.LastName)
		case "payer_id":
			err = json.Unmarshal(rawMsg, &self.private.PayerId)
		case "shipping_address":
			err = json.Unmarshal(rawMsg, &self.private.ShippingAddress)
		default:
			// Ignoring unknown property
		}

		if err != nil {
			return err
		}
	}
	return nil
}
